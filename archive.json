{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-03-08T00:20:08.775713+00:00",
  "repo": "tlswg/draft-ietf-tls-external-psk-importer",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU0Mjg3OTA3OTY=",
      "title": "Provide a sample importer API, and add client/server roles to mitigate Selfie attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See: https://eprint.iacr.org/2019/347.pdf",
      "createdAt": "2019-04-03T14:10:29Z",
      "updatedAt": "2019-09-28T00:27:38Z",
      "closedAt": "2019-09-28T00:27:38Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed with the `context` slot via #12 and #14. Closing!",
          "createdAt": "2019-09-28T00:27:38Z",
          "updatedAt": "2019-09-28T00:27:38Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU0Mjg3OTU3MjA=",
      "title": "Replace \"TLS 1.3 PSK resumption\" with \"TLS 1.3 PSK authentication\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\"TLS 1.3 supports pre-shared key s/resumption/authentication\"",
      "createdAt": "2019-04-03T14:19:25Z",
      "updatedAt": "2019-05-16T14:14:15Z",
      "closedAt": "2019-05-16T14:14:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #8.",
          "createdAt": "2019-05-16T14:14:14Z",
          "updatedAt": "2019-05-16T14:14:14Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU0Mjg3OTU5NTA=",
      "title": "Add text about deployment",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both endpoints must adopt importers for interoperability's sake. ",
      "createdAt": "2019-04-03T14:19:50Z",
      "updatedAt": "2019-05-16T14:14:05Z",
      "closedAt": "2019-05-16T14:14:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #8.",
          "createdAt": "2019-05-16T14:14:04Z",
          "updatedAt": "2019-05-16T14:14:04Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU0Mjg3OTc4NTk=",
      "title": "Consider replacing \"into TLS\" with \"for TLS\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-03T14:23:32Z",
      "updatedAt": "2019-05-09T00:18:49Z",
      "closedAt": "2019-05-09T00:18:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "NTBF.",
          "createdAt": "2019-05-09T00:18:49Z",
          "updatedAt": "2019-05-09T00:18:49Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU0MzEyNjQwMzM=",
      "title": "State that \"tls12\" is used for DTLS 1.2 and \"tls13\" is used for DTLS 1.3.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-10T01:34:36Z",
      "updatedAt": "2019-05-16T14:13:48Z",
      "closedAt": "2019-05-16T14:13:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #8.",
          "createdAt": "2019-05-16T14:13:47Z",
          "updatedAt": "2019-05-16T14:13:47Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU0MzEyNjQ0Mjc=",
      "title": "Can clients retry connections without imported PSKs if external PSKs yield connection failure due to unknown identity?",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-10T01:36:39Z",
      "updatedAt": "2019-05-16T14:13:57Z",
      "closedAt": "2019-05-16T14:13:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #8.",
          "createdAt": "2019-05-16T14:13:57Z",
          "updatedAt": "2019-05-16T14:13:57Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU0NzY1Njc0NDY=",
      "title": "Change intended status",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/11",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Experimental to PS or Informational? Or leave it as is?",
      "createdAt": "2019-08-04T15:54:56Z",
      "updatedAt": "2019-10-02T12:01:09Z",
      "closedAt": "2019-10-02T12:01:09Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU0ODg4OTMzODc=",
      "title": "ImportedIdentity.label ",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/15",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Why is this a string and not the protocol version number?  It sure would be easier that way.",
      "createdAt": "2019-09-04T01:25:41Z",
      "updatedAt": "2019-09-28T00:26:19Z",
      "closedAt": "2019-09-28T00:26:19Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In writing up #16, I realize now that the combination of label and hash is what is being used to identify a KDF.  I think that you need to allow for the HashAlgorithm to be replaced by something else in future, or for different applications other than TLS.  It might pay to instead reduce the tuple of (tls version, hash) to a single identifier that says tls12_sha256, tls13_hkdf_sha256, which might broaden applicability.\r\n\r\nThat could be crazy-talk though.  Either way, it would be good to understand this better in the abstract so as to make a less ad hoc decision about what is being identified and then how.",
          "createdAt": "2019-09-04T01:34:23Z",
          "updatedAt": "2019-09-04T01:34:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why is this a string and not the protocol version number? It sure would be easier that way.\r\n\r\nI agree that the info string should probably just be a version. I imagine there will be a use case where someone wants to, say, import with the label \"tls1.3 special sauce\". In this case, they could KDF their PSK with the the \"special sauce\" string and *then* import with the \"tls13\" label. And at this point, it might as well be the version number. Let's assume this will be done, and the new field will be called \"protocol\".\r\n\r\nSo that leaves the question about what to do for the hash algorithm. As you point out, removing the HashAlgorithm dependency would be good for the future. (We have a TODO in the draft to that effect.) So the question then becomes, do we merge whatever this new field is with \"protocol,\" or do we keeep them separate. I don't think we need to merge these for \"level matching\" or other purposes, so I'm inclined to keep them separate. Thus, how about thee following structure:\r\n\r\n```\r\nstruct {\r\n  opaque external_identity<1...2^16-1>;\r\n  uint16 protocol;\r\n  uint16 kdf;\r\n} ImportedIdentity;\r\n```\r\n\r\nWhere `protocol` is a uint16 codepoint, and `kdf` is an HPKE-like identifier [1] for a KDF, such as HKDF-SHA256 or HKDF-SHA512. We could then define the importer with respect to this KDF, rather than baking in a hard dependency on HKDF. \r\n\r\n@davidben, @martinthomson, what do you think?\r\n\r\n[1] https://tools.ietf.org/html/draft-irtf-cfrg-hpke-00#section-7.2",
          "createdAt": "2019-09-07T15:11:02Z",
          "updatedAt": "2019-09-07T15:11:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems reasonable - I think that there is *some* reason to separate target protocol (and version, as a tuple) from the KDF that is used.\r\n\r\nThere's a trick in terms of finding the right level of identification to use for the protocol.  I suspect that seeding a registry with 0x0304 and 0x0303 is probably the right way to do this.  That has the effect of constraining TLS a little in how it chooses version numbers, but I think that's workable.\r\n\r\n(As a reminder, in case you thought this was too easy, QUIC uses a 32-bit identifier for versions.  We'd need a mapping QUIC.  @chris-wood just makes this look simple.)",
          "createdAt": "2019-09-09T04:52:24Z",
          "updatedAt": "2019-09-09T04:52:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently the context binds the info string (or proposed `protocol` field) to the version of TLS, not to the calling application or protocol (QUIC). ",
          "createdAt": "2019-09-09T14:24:20Z",
          "updatedAt": "2019-09-09T14:24:20Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "Do we want to allow the output of the KDF to be anything other that Nh?  Right now, L is always Hash.length, which I think i the Nh value associated with the HPKE-like identifier.",
          "createdAt": "2019-09-09T16:05:38Z",
          "updatedAt": "2019-09-09T16:05:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Right now, L is always Hash.length, which I think i the Nh value associated with the HPKE-like identifier.\r\n\r\nCorrect! I can't see a reason why we'd want the KDF output to be something different. Do you have a use case in mind?",
          "createdAt": "2019-09-09T16:09:32Z",
          "updatedAt": "2019-09-09T16:09:32Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "If we want this to apply to other contexts, like your special sauce above, it is unclear to me that Hash.length is always the right answer.",
          "createdAt": "2019-09-09T16:12:44Z",
          "updatedAt": "2019-09-09T16:12:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The point of the importer is to produce a PSK for use in TLS. Why would the context affect the length?",
          "createdAt": "2019-09-09T16:13:52Z",
          "updatedAt": "2019-09-09T16:13:52Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "The discussion of #16 is opening this for other protocol contexts too.",
          "createdAt": "2019-09-09T16:18:41Z",
          "updatedAt": "2019-09-09T16:18:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @russhousley I made the proposed change in #17. Please have a look!",
          "createdAt": "2019-09-09T20:29:13Z",
          "updatedAt": "2019-09-09T20:29:13Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "Works for me",
          "createdAt": "2019-09-09T20:45:34Z",
          "updatedAt": "2019-09-09T20:45:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #18.",
          "createdAt": "2019-09-28T00:26:19Z",
          "updatedAt": "2019-09-28T00:26:19Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU0ODg4OTQ1OTM=",
      "title": "KDF-bound in, KDF-bound out",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/16",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In reviewing the draft, it was not clear that the input PSK was also bound to a hash function, but that the process could produce a derived PSK bound to any hash function.  As this is the primary function of the document, that seems problematic.\r\n\r\nThis seems to be the answer to this:\r\n\r\n> In particular, it describes how KDF-bound PSKs can be differentiated by different hash algorithms to produce a set of candidate PSKs, each of which are bound to a specific hash function.\r\n\r\nI assume that this means KDF rather than hash function throughout (the KDF-bound thing seems right).  But it never really comes out and says that:\r\n\r\n> This process takes a PSK, which is bound to a specific KDF.  The output of this process is a PSK that is bound to a TLS KDF.  This document only describes output KDF functions that are defined in TLS, so the TLS 1.2 PRF or HKDF in TLS 1.3.\"",
      "createdAt": "2019-09-04T01:31:30Z",
      "updatedAt": "2019-09-28T00:26:40Z",
      "closedAt": "2019-09-28T00:26:40Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> it was not clear that the input PSK was also bound to a hash function\r\n\r\nIt's optionally bound to a hash function. In defining external PSKs, the document states that the \"associated KDF (and hash function) may be undefined.\" Do you think it would be more clear to put this in the introduction? (Minimally, as you point out, the introduction should not assume that the KDF-bound PSK as input is not quite right, so that should probably change.)\r\n\r\nAs for the second comment (KDF output), that's not quite the goal. The importer binds input PSKs to a hash via HKDF, not via the TLS KDF. (The TLS 1.2 PRF is not used.) \r\n\r\nTo summarize, my view is that the contract is more or less: optional hash-bound PSK in, hash-bound PSK out. Does that seem incorrect to you?",
          "createdAt": "2019-09-07T14:47:32Z",
          "updatedAt": "2019-09-07T14:47:32Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, my understanding is that we don't have any support for optional bindings on input.  I'm inclined to say that we need stricter constraints on input.  Namely that they are bound to a specific KDF and that KDF needs to take a context struct in the form this document describes.\r\n\r\nYes, limiting the concrete instantiation of this to HKDF is fine (and the only sensible option).  However, if you don't bind the input key more tightly, you will end up shifting the problem you set out to solve one step further out.",
          "createdAt": "2019-09-09T04:56:01Z",
          "updatedAt": "2019-09-09T04:56:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Namely that they are bound to a specific KDF and that KDF needs to take a context struct in the form this document describes.\r\n\r\nI'm not sure I follow anymore! In my view, the problem we aim to solve is one where the external PSK was *not* provisioned \"correctly,\" i.e., with the right hash (KDF) function in mind. It's just a plain old n-bit key. The importer is designed to bind this key to a specific hash (KDF). \r\n\r\nIf the machinery that produced external PSKs was forced to change to accommodate a KDF, then it seems that machinery could also vend PSKs that do precisely what the importer does. Namely, differentiate by (context, protocol, hash/KDF). \r\n\r\nPerhaps I'm misunderstanding your point. Can you please clarify? If you're looking for a specific change, could you please make a suggestion?",
          "createdAt": "2019-09-09T14:29:02Z",
          "updatedAt": "2019-09-09T14:29:02Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "In TLS 1.2 and earlier, PSKs were not bound to a KDF.  Now in TLS 1.3, a PSK is required to be bound to a KDF.  I thought the goal was to start with a PSK that is not bound to a KDF and produce a PSK that can be used in the desired context.  So, the input is always a \"plain old n-bit key\" (Chris' words).  The output, when the desired context is TLS 1.3, must include the KDF.",
          "createdAt": "2019-09-09T15:50:34Z",
          "updatedAt": "2019-09-09T15:50:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The output, when the desired context is TLS 1.3, must include the KDF.\r\n\r\nThis is *exactly* what the importer does. Do you disagree?",
          "createdAt": "2019-09-09T15:53:54Z",
          "updatedAt": "2019-09-09T15:53:54Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "It is not clear to me what the importer does if I want the context to be TLS 1.2.",
          "createdAt": "2019-09-09T16:09:58Z",
          "updatedAt": "2019-09-09T16:09:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It changes the info (or proposed `protocol` field) value and runs the key through a KDF. ",
          "createdAt": "2019-09-09T16:14:26Z",
          "updatedAt": "2019-09-09T16:14:26Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "Right, I get that, which I think will bind the resulting key to TLS 1.2 but allow any KDF.  I think the document should be explicit if that is the case.",
          "createdAt": "2019-09-09T16:17:29Z",
          "updatedAt": "2019-09-09T16:17:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at #17, I think that you want to bind this to the TLS 1.2 KDF differently by using a different KDF identifier.  The identifiers you have are only good for TLS 1.3.\r\n\r\nYou probably also want security considerations addressing the fact that the TLS 1.2 has this odd characteristic.",
          "createdAt": "2019-09-10T02:40:05Z",
          "updatedAt": "2019-09-10T02:40:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  I think that you want to bind this to the TLS 1.2 KDF...\r\n\r\nCan you please elaborate on why you think this is necessary? \r\n\r\nAs an example, let's assume I have an external PSK and I want to import it for TLS 1.2 and 1.3, and I only want to support one hash function (or KDF). Let's say that KDF is HKDF_SHA256. I would then import with the tuples (0x0303, HKDF_SHA256) and (0x0304, HKDF_SHA256), and it seems I'd have the desired separation.\r\n\r\nIn other words, I don't see a technical reason why importing PSKs for TLS 1.2 requires use of the TLS 1.2 KDF (PRF). ",
          "createdAt": "2019-09-14T13:44:49Z",
          "updatedAt": "2019-09-14T13:44:49Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "I think we are saying the same thing, except that when the protocol version is TLS 1.2 that it will be used with the PRF that is negotiated in the TLS 1.2 handshake.  I just think the document should say that explicitly.",
          "createdAt": "2019-09-14T15:55:23Z",
          "updatedAt": "2019-09-14T15:55:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> except that when the protocol version is TLS 1.2 that it will be used with the PRF that is negotiated in the TLS 1.2 handshake\r\n\r\nThis is *not* what I'm saying! I'm saying *do not use the TLS 1.2 PRF*. Rather, use HKDF. Can you clarify why you think the TLS 1.2 PRF should be used instead?",
          "createdAt": "2019-09-14T17:48:10Z",
          "updatedAt": "2019-09-14T17:48:10Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "There are two thongs that are being confused here.  First, the one used to create the protocol-version-specific key.  This is the one that you want to always use HKDF.  That is fine with me.  Second, with TLS 1.3, it is bound to a particular hash function.  I am saying that when a key is derived for TLS 1.2 the document should say that it will be used with whatever PRF is negotiated in the TLS handshake.  Right now, I do d not see anything about that in the document at all.",
          "createdAt": "2019-09-14T19:36:15Z",
          "updatedAt": "2019-09-14T19:36:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for clarifying! \r\n\r\n> I am saying that when a key is derived for TLS 1.2 the document should say that it will be used with whatever PRF is negotiated in the TLS handshake.\r\n\r\nIf I use an external PSK for TLS 1.2 today, without any import step, it's already the case that it's used with whatever PRF is negotiated in the handshake. The importer does not change that, and therefore I think doesn't need to say anything about that.",
          "createdAt": "2019-09-14T19:43:50Z",
          "updatedAt": "2019-09-14T19:43:50Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "I just think it would be better say it since TLS 1.3 had a binding but TLS 1.2 does not.  You now understand my point, so I will leave it to you as author.",
          "createdAt": "2019-09-14T21:41:18Z",
          "updatedAt": "2019-09-14T21:41:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #18.",
          "createdAt": "2019-09-28T00:26:39Z",
          "updatedAt": "2019-09-28T00:26:39Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU1MDE1MDA2Mzc=",
      "title": "Document security requirements and properties",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This includes a pointer to formal analysis, once complete.",
      "createdAt": "2019-10-02T13:47:22Z",
      "updatedAt": "2019-10-24T18:49:41Z",
      "closedAt": "2019-10-24T18:49:41Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Partially fixed by #21. Closing for now.",
          "createdAt": "2019-10-24T18:49:41Z",
          "updatedAt": "2019-10-24T18:49:41Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU1MjYzMjU5MjM=",
      "title": "Please be clearer about the PSK ID",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/23",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The document says:\r\n> Thus, importers induce no protocol changes with the exception of expanding the set of PSK identities sent on the wire.  \r\n\r\nAside from this statement needing update in light of the changes to the binder label, the core statement here isn't expanded upon.\r\n\r\nThe document needs to very clearly say that the PSK ID that is sent in the psk extension is *literally* the serialized content of `ImportedIdentity`.",
      "createdAt": "2019-11-21T02:27:43Z",
      "updatedAt": "2019-11-26T19:10:44Z",
      "closedAt": "2019-11-26T19:10:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #24.",
          "createdAt": "2019-11-26T19:10:44Z",
          "updatedAt": "2019-11-26T19:10:44Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU1ODk2MzY4MDM=",
      "title": "Clarify MUSTs",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Rob Sayre:\r\n\r\n~~~\r\nI'm not sure how violations of these requirements would result in poor interoperability:\r\n\r\n Clients which import external keys TLS MUST NOT use these keys for\r\n any other purpose. Moreover, each external PSK MUST be associated\r\n with at most one hash function.\r\n\r\nThese seem like aspirational security goals. It would be better to describe the consequences of violating these conditions.\r\n~~~\r\n\r\nWe should note the latter is a requirement from Section 4.2.11 of RFC8446. Let's also fix the typo \"import external keys *for* TLS...\"",
      "createdAt": "2020-03-28T18:52:51Z",
      "updatedAt": "2020-04-08T01:10:10Z",
      "closedAt": "2020-04-08T01:10:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #28.",
          "createdAt": "2020-04-08T01:10:10Z",
          "updatedAt": "2020-04-08T01:10:10Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU2MDQzODk3ODY=",
      "title": "Replace use of \"clients\" with \"endpoints\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/30",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://mailarchive.ietf.org/arch/msg/tls/d7ktdMu645J9pMhHB_Rgnx4R1X0/:\r\n\r\nRelated to this, where Section 3 states, \"Clients which import external keys MUST NOT use either the external keys or the derived keys for any other purpose,\" should \"Clients\" be \"Clients and servers\" or simply \"Endpoints\"?",
      "createdAt": "2020-04-22T01:43:03Z",
      "updatedAt": "2020-04-22T18:29:36Z",
      "closedAt": "2020-04-22T18:29:36Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU2MDQzOTA2NzY=",
      "title": "Clarify that EPSKs with the same identity will yield the same imported PSK",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/31",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://mailarchive.ietf.org/arch/msg/tls/d7ktdMu645J9pMhHB_Rgnx4R1X0/:\r\n\r\n> a. Distinct identities?  Sec. 3 states \"Non-imported and imported PSKs \r\n> are distinct since their identities are different on the wire.\"  We \r\n> have two concerns about this statement.  First, the statement appears \r\n> to suggest that if two EPSKs have different identities, then they must \r\n> have different secret values.  But couldn't two EPSKs have the same \r\n> secret value yet employ different identities for convenience?  For \r\n> example, an endpoint might identify the same EPSK with a domain name in \r\n> some cases and with an IP address in others.  \r\n\r\n",
      "createdAt": "2020-04-22T01:46:04Z",
      "updatedAt": "2020-04-22T18:29:30Z",
      "closedAt": "2020-04-22T18:29:30Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU2MDQzOTQyMDk=",
      "title": "Link to Selfie upon first reference",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently later in the document.",
      "createdAt": "2020-04-22T01:57:32Z",
      "updatedAt": "2020-04-22T18:29:24Z",
      "closedAt": "2020-04-22T18:29:24Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU2MDQzOTQ2MDU=",
      "title": "Remove RFC1035 and RFC6234 references",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/33",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "idnits caught this. Oops.",
      "createdAt": "2020-04-22T01:58:52Z",
      "updatedAt": "2020-04-22T18:29:19Z",
      "closedAt": "2020-04-22T18:29:19Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU3MTQ5NTc4MTI=",
      "title": "Address Roman's AD comments",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/37",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "** Section 1.  Editorial.  Expand acronym on first use:\r\n-- s/TLS 1.2 PRF/TLS 1.2 Pseudorandom Function (PRF)/\r\n-- s/KDF/Key Derivation Function (KDF)/\r\n\r\n** Section 1. Editorial.  Since the text says \"... this document specifies a PSK Importer interface ... for use in D(TLS 1.3)\" perhaps the this scoping should also be upfront in the first sentence too:\r\ns/TLS 1.3 [RFC8446] supports/(D)TLS 1.3 [RFC8446][ID-DTLS]/\r\n\r\n** Section 4.1.  Editorial.  Per \"The list of 'target_kdf' ...\", other parts of this text refer to elements of struct ImportIdentity with the notation \"ImportedIdentity.*\".  Consider s/The list of \"target_kdf\" values/The list of ImportedIdentity.target_kdf values/\r\n\r\n** Section 4.1.\r\nIf the EPSK is a key derived from some other protocol or\r\n  sequence of protocols, ImportedIdentity.context MUST include a\r\n  channel binding for the deriving protocols [RFC5056].\r\n\r\nTo the end of this normative guidance, I'd recommend adding something to the effect of: \"The details of this binding will be protocol specific and out of scope in this document\".\r\n\r\n** Section 4.1.  Per \"If no hash function is specified, SHA-256 MUST be used\"\r\n\r\n-- Please provide a reference for SHA-256 (per \"... If no hash function is specified, SHA-256 MUST be used\").  \r\n\r\n-- It is likely worth saying that this is the equivalent of HKDF_SHA256 (i.e., 0x0001)\r\n\r\n** Section 4.1.  Per \"EPSKs may be imported before the started of the connection ...\" and \"EPSKs may also be imported for early data use ...\" should be these be a normative MAYs?\r\n\r\n** Section 4.1.  Per \"Minimally, that means ALPN, QUIC ... must be provisioned alongside these EPSK\"\r\n-- Please expand ALPN\r\n\r\n-- should this be a normative MUST?\r\n\r\n** Section 9.  Per the columns in the registry:\r\n-- Is there a reason why there isn't a Reference column in the registry to capture which specification describes the particular KDF?  I think it needs one to eliminate guesswork from the label in \"KDF Description\" to an algorithm.  \r\n\r\n-- Was a Recommended column (and the associated processed for populating it like a few of the other TLS registries) discussed/considered?\r\n\r\n** Section 9.  While it is implied by the label, the text doesn't explicitly say what HKDF_SHA256 and _SHA384 are (per previous comment about needing a reference).",
      "createdAt": "2020-10-05T15:48:46Z",
      "updatedAt": "2020-12-03T16:00:56Z",
      "closedAt": "2020-12-03T16:00:56Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU3NDM0OTkyMjk=",
      "title": "Genart Review from Brian Carpenter",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/38",
      "state": "CLOSED",
      "author": "jsalowey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Document: draft-ietf-tls-external-psk-importer-05\r\nReviewer: Brian Carpenter\r\nReview Date: 2020-10-07\r\nIETF LC End Date: 2020-10-15\r\nIESG Telechat date: \r\n\r\nSummary: Ready with issues\r\n--------\r\n\r\nIssues:\r\n-------\r\n\r\n>1.  Introduction\r\n>\r\n>    Applications SHOULD provision separate PSKs for TLS 1.3 and prior\r\n>    versions when possible.\r\n\r\nI think that \"when possible\" could easily be used as a loophole by a\r\nlazy implementer. (\"Impossible, because I'd have to refactor my code.\")\r\nSince presumably this rule is to avoid all risk of a \"related output\"\r\ncryptanalytic vulnerability, why weaken the RFC2119 definition of SHOULD?\r\nThe formal definition of SHOULD is stronger, with \"the full implications\r\nmust be understood and carefully weighed before choosing a different\r\ncourse.\" So I suggest simply deleting \"when possible\".\r\n\r\n>6.  Incremental Deployment\r\n>\r\n>   Recall that TLS 1.2 permits computing the TLS PRF with any hash\r\n>   algorithm and PSK.  Thus, an EPSK may be used with the same KDF (and\r\n>   underlying HMAC hash algorithm) as TLS 1.3 with importers.  However,\r\n>   critically, the derived PSK will not be the same since the importer\r\n>   differentiates the PSK via the identity and target KDF and protocol.\r\n>   Thus, PSKs imported for TLS 1.3 are distinct from those used in TLS\r\n>   1.2, and thereby avoid cross-protocol collisions.  Note that this\r\n>   does not preclude endpoints from using non-imported PSKs for TLS 1.2.\r\n>   Indeed, this is necessary for incremental deployment.\r\n\r\nI read this three times and I have to ask whether \"TLS 1.2\" is\r\nreally what you want in the penultimate line.\r\n\r\nNits:\r\n-----\r\n\r\n>4.1.  External PSK Diversification\r\n...\r\n>   ImportedIdentity.target_protocol MUST be the (D)TLS protocol version\r\n>   for which the PSK is being imported.  For example, TLS 1.3 [RFC8446]\r\n>   and QUICv1 [QUIC] use 0x0304.\r\n\r\nAs far as I can tell, [QUIC] doesn't specify this, but draft-ietf-quic-tls\r\ndoes specify that QUICv1 uses TLS1.3. So the phrasing is a bit misleading.\r\nMaybe:\r\n\r\n  For example, TLS 1.3 [RFC8446] uses 0x0304, which will therefore also be\r\n  used by QUICv1 [QUIC-TLS].\r\n\r\nAre all the RFC2119 terms capitalised when required? For example, there\r\nare lower case 'may' and 'must' in the last paragraph of section 4.1\r\n(External PSK Diversification). I couldn't determine whether they were\r\nintended to be normative.\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2020-11-16T06:03:21Z",
      "updatedAt": "2020-12-03T16:01:15Z",
      "closedAt": "2020-12-03T16:01:15Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3NDM0OTk4MzM=",
      "title": "OPSDIR review from Al Morton",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/39",
      "state": "CLOSED",
      "author": "jsalowey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reviewer: Al Morton\r\nReview result: Has Nits\r\n\r\nOPS-DIR Review of:\r\nImporting External PSKs for TLS\r\ndraft-ietf-tls-external-psk-importer-05\r\n\r\nNote that Brian Carpenter provided a useful review for GEN-ART, far beyond\r\ngeneral questions. Brian's comments on Section 6, Incremental Deployment, are\r\nrelevant to operational considerations, which are the focus of this review.\r\n\r\nThe draft provides a useful capability and considers possible issues stemming\r\nfrom interaction with (D)TLS 1.2. There are some implementations and other\r\nparties are interested.\r\n\r\nNits:\r\n\r\nIntro:not expanded on first use\r\nPRF\r\nKDF\r\n\r\n3.1 Terminology: one-too-many \"and\" in:\r\n...\r\n   *  Imported PSK (IPSK): A PSK derived from an EPSK, External\r\n      Identity, optional context string, and target protocol and KDF.\r\n",
      "createdAt": "2020-11-16T06:04:43Z",
      "updatedAt": "2020-12-03T16:01:15Z",
      "closedAt": "2020-12-03T16:01:15Z",
      "comments": [
        {
          "author": "jsalowey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nits in the introduction are also listed in Roman's review.  \r\n\r\nsection 3.1 should be updated. ",
          "createdAt": "2020-11-16T06:07:36Z",
          "updatedAt": "2020-11-16T06:07:36Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4MTU5MDA4ODE=",
      "title": "Address Ben's review",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/issues/42",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[https://mailarchive.ietf.org/arch/msg/tls/s1VmiaTWCFPjrJ_Ly60qU7EhjuE/](https://mailarchive.ietf.org/arch/msg/tls/s1VmiaTWCFPjrJ_Ly60qU7EhjuE/)",
      "createdAt": "2021-02-24T22:32:52Z",
      "updatedAt": "2022-03-07T14:17:57Z",
      "closedAt": "2022-03-07T14:17:57Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5OTUwMDYw",
      "title": "Add updates based on list feedback.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-11T12:37:17Z",
      "updatedAt": "2019-03-11T20:40:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "ded23f4102cb70b57a9709ae02a4965a70c200d4",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/updates",
      "headRefOid": "ee1c5054834b5e94bded34526cb85473fd5e147c",
      "closedAt": "2019-03-11T20:40:23Z",
      "mergedAt": "2019-03-11T20:40:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "84e8bf1599bb0750f6856532b5b5003510fa035d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDM3MzM0",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T19:23:56Z",
          "updatedAt": "2019-03-11T19:55:42Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Should it be \"quicv1\" or just \"tls13\"? My recollection is QUIC keeps the \"tls13\" label for most of it and only changes the label at the end for the traffic secrets, since those are actually a different use of the key. That would suggest \"tls13\".\r\n\r\nIn particular, does QUIC pin to TLS 1.3, or can TLS 1.3 rev independently of QUIC? If the former, either probably works. If the latter, I think we'd want it to be whatever TLS 1.3 uses.",
              "createdAt": "2019-03-11T19:23:56Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 34,
              "body": "If this is meant to support multiple protocols, the `HashAlgorithm` bit is probably a bit overly-specific. Maybe my other protocol doesn't use TLS hash algorithms, or maybe it uses the secret in a totally different way altogether. (See also the \"hardcoded\" SHA-256 down in the TLS 1.2 section.)\r\n\r\nA thought: we could allocate labels like \"tls13,sha256\" and \"tls13,sha384\". Or maybe explicitly have two levels of labels?",
              "createdAt": "2019-03-11T19:32:24Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 45,
              "body": "Should `Hash.length` be instead the PSK size that the particular IPSK use wants? I suppose TLS 1.3 doesn't really care, but if the goal is to support other protocols, they may have opinions on key size. (Maybe it becomes an AES key later, I dunno.)",
              "createdAt": "2019-03-11T19:44:00Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 52,
              "body": "Nit: maybe instead \"Endpoints MUST import and derive an ipsk for each hash function used by each ciphersuite they support.\". If I offer TLS_AES_128_GCM_SHA256 and TLS_CHACHA20_POLY1305_SHA256, I don't need two of them.",
              "createdAt": "2019-03-11T19:45:37Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 82,
              "body": "By \"TLS 1.2\" here, do you mean just TLS 1.2 or TLS 1.0 through 1.2? TLS \"1.2\" PSKs exist in all three. OpenSSL's implementation, at least, freely mixes them up.\r\n\r\nAlthough I'm a little confused how this paragraph is meant to interact with \"As specified, key importers do not affect TLS 1.2.\". It seems like the document is specifying how to stuff this draft's notion of EPSK into TLS 1.2",
              "createdAt": "2019-03-11T19:49:50Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 17,
              "body": "I feel like I haven't really done anything yet to be considered an author, but I don't object. :-)",
              "createdAt": "2019-03-11T19:51:01Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 94,
              "body": "s/protposal/proposal/",
              "createdAt": "2019-03-11T19:51:48Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 88,
              "body": "I'm a little confused what this section is meant to describe. It seems to have a sketch of something, but nothing terribly concrete yet. Were you thinking that there would ultimately be an actual mechanism in here, or is this just notes for a future draft?",
              "createdAt": "2019-03-11T19:55:33Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDUzMDU3",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T19:58:29Z",
          "updatedAt": "2019-03-11T19:58:29Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Your understanding of QUIC is correct! Even with that behavior, I opted with this since I tend to think the original design where \"quic\" was used as the HKDF prefix was safer. I'll change it here, though, since it does seem to be a minor point.",
              "createdAt": "2019-03-11T19:58:29Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDU0NDA3",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:01:11Z",
          "updatedAt": "2019-03-11T20:01:12Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Interesting idea! I'll leave this as a \"TODO\" in the draft as a potential alternative.",
              "createdAt": "2019-03-11T20:01:12Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDU1NTc1",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:03:45Z",
          "updatedAt": "2019-03-11T20:03:45Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Good point! I'll generalize it to be the length of the CipherSuite key, with a note that says this is the same as Hash.length in 1.3.",
              "createdAt": "2019-03-11T20:03:45Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDU1OTIx",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:04:31Z",
          "updatedAt": "2019-03-11T20:04:31Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Fixed!",
              "createdAt": "2019-03-11T20:04:31Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDU2MjA1",
          "commit": {
            "abbreviatedOid": "e2a5727"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:05:09Z",
          "updatedAt": "2019-03-11T20:05:09Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah, it's just meant to be a note for an idea to fill out later, if it's something the WG should want.",
              "createdAt": "2019-03-11T20:05:09Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDU5MTU4",
          "commit": {
            "abbreviatedOid": "7fb5fd5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:11:33Z",
          "updatedAt": "2019-03-11T20:11:33Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "It's meant to refer to all previous versions, so I changed the title and removed some bits.",
              "createdAt": "2019-03-11T20:11:33Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDYwODEw",
          "commit": {
            "abbreviatedOid": "7fb5fd5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:15:07Z",
          "updatedAt": "2019-03-11T20:32:17Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Nit: s/deisgn/design/\r\n\r\nYet another option would be that your protocol picks a single \"label\", and then anything following it is your business. For TLS 1.3, we use HashAlgorithm. Future TLS versions might have other opinions.",
              "createdAt": "2019-03-11T20:15:07Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            },
            {
              "originalPosition": 52,
              "body": "Hrm. This reads to me a little funny since it's no longer immediately obvious that all cipher suites that share a hash also share a length. I think my comment might have made more sense in the combined label alternate design above. In that interpretation, the importer specifies label + desired size.\r\n\r\nMaybe keep it as Hash.length right now and leave this with the other TODO above? (I think I actually used ImportedIdentity.hash.length in the universal PSKs draft, but I don't think it actually matters one way or another.)",
              "createdAt": "2019-03-11T20:31:50Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDcxNDYw",
          "commit": {
            "abbreviatedOid": "7fb5fd5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T20:37:21Z",
          "updatedAt": "2019-03-11T20:37:21Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That works for me, too!",
              "createdAt": "2019-03-11T20:37:21Z",
              "updatedAt": "2019-03-11T20:37:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc3MjA3NjE3",
      "title": "Fix various issues based on reviews from the list.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/8",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Importantly, add details regarding incremental deployment, and clarify\r\nlabel values for non TCP-based variants of TLS.",
      "createdAt": "2019-05-09T00:29:05Z",
      "updatedAt": "2019-05-14T20:38:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "84e8bf1599bb0750f6856532b5b5003510fa035d",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/nits",
      "headRefOid": "4ae40f896d1dc71a6b2b85141c2118c61cb1c8a1",
      "closedAt": "2019-05-14T20:38:43Z",
      "mergedAt": "2019-05-14T20:38:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f05488490472a1910949da87efb0fd5781b01e4c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM3NDUwODQ0",
          "commit": {
            "abbreviatedOid": "87e94f6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-14T19:20:23Z",
          "updatedAt": "2019-05-14T19:23:38Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "s/offer/offering/",
              "createdAt": "2019-05-14T19:20:23Z",
              "updatedAt": "2019-05-14T20:38:28Z"
            },
            {
              "originalPosition": 34,
              "body": "(I didn't find any changed text here. Just to confirm, this was just a reflow?)",
              "createdAt": "2019-05-14T19:21:31Z",
              "updatedAt": "2019-05-14T20:38:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM3NDg3NjQw",
          "commit": {
            "abbreviatedOid": "87e94f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-14T20:36:47Z",
          "updatedAt": "2019-05-14T20:36:48Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yep!",
              "createdAt": "2019-05-14T20:36:47Z",
              "updatedAt": "2019-05-14T20:38:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM3NDg4NTQz",
          "commit": {
            "abbreviatedOid": "4ae40f8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-14T20:38:30Z",
          "updatedAt": "2019-05-14T20:38:30Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Fixed!",
              "createdAt": "2019-05-14T20:38:30Z",
              "updatedAt": "2019-05-14T20:38:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzODU4ODA0",
      "title": "Add layered security contexts.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/9",
      "state": "CLOSED",
      "author": "jhoyla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The new design allows users to include security contexts into the PSK binders, ensuring that both parties agree on the source of the OOB PSK. \r\n\r\nThe security contexts are a list of pairs `<channel_binding, secret>`, which in the vanilla case will be empty. However if the OOB PSK is established using a different protocol that provides different security guarantees, then this structure allows you to reason about the effect of those properties on the properties of the TLS channel. ",
      "createdAt": "2019-07-02T18:06:57Z",
      "updatedAt": "2019-08-15T12:22:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "7991731c388b8c62751a2a917c706c7820e01135",
      "headRepository": "jhoyla/draft-ietf-tls-external-psk-importer",
      "headRefName": "security-contexts",
      "headRefOid": "88dae99f3092c1bb101eb2fcae7712f3bdd0be64",
      "closedAt": "2019-08-15T12:22:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben Please could you take a look at this? ",
          "createdAt": "2019-07-08T16:51:57Z",
          "updatedAt": "2019-07-08T16:51:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR for now since it's been overcome by events!",
          "createdAt": "2019-08-15T12:22:59Z",
          "updatedAt": "2019-08-15T12:22:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDY2MDI4",
          "commit": {
            "abbreviatedOid": "564e35f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "First pass complete. Great start! ",
          "createdAt": "2019-07-02T18:15:40Z",
          "updatedAt": "2019-07-02T18:21:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: Author names should be alphabetical. :-)",
              "createdAt": "2019-07-02T18:15:40Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nTLS 1.2 also supports PSK-based handshakes, but does not require they be provisioned with a single hash function. Any PSK may be used with any supported hash function and the TLS 1.2 PRF.\r\n```",
              "createdAt": "2019-07-02T18:16:27Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nThe design allows for a PSK to be imported into TLS 1.3 with any supported hash function.\r\n```",
              "createdAt": "2019-07-02T18:17:10Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nPSKs provisioned with one hash function can be processed to produce a set of candidate PSKs, each of which is bound to a potentially different and specific hash function.\r\n```",
              "createdAt": "2019-07-02T18:17:41Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nNotably, this makes no wire format changes and requires no change to the TLS 1.3 key schedule.\r\n```",
              "createdAt": "2019-07-02T18:18:02Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 57,
              "body": "nit: has OOB been defined by now?",
              "createdAt": "2019-07-02T18:18:25Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 93,
              "body": "Can we give examples of what values this might take, and how deployments might use it?",
              "createdAt": "2019-07-02T18:19:30Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 94,
              "body": "This needs a bit more explanation, I think. Can we add some more details?",
              "createdAt": "2019-07-02T18:19:49Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 94,
              "body": "nit: Selfie attack citation missing",
              "createdAt": "2019-07-02T18:20:06Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\n  } PriorContext\r\n```\r\n\r\nThis should also be defined before it's used in `Context`, I think.",
              "createdAt": "2019-07-02T18:20:40Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 108,
              "body": "As above, I think descriptions would help. Perhaps we should add a section on OOB PSK deployments and how they might translate to different `Context` values?",
              "createdAt": "2019-07-02T18:21:45Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4NjA0",
          "commit": {
            "abbreviatedOid": "f987f5c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the updates! Still looking good. We're getting closer.",
          "createdAt": "2019-07-04T00:51:05Z",
          "updatedAt": "2019-07-04T01:01:18Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "```suggestion\r\nIn this case, there are two clients and two servers that know the PSK, since each endpoint acts as both client and server.\r\n```",
              "createdAt": "2019-07-04T00:51:05Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\nThis is because neither agent can distinguish between itself and its peer given only a pre-shared key identifier.\r\n```",
              "createdAt": "2019-07-04T00:52:22Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nBy hashing a distinguishing `client_id` value into the PSK binder, a server that received a reflected `ClientHello` would be unable to verify the binder, and would reject the connection.\r\n```",
              "createdAt": "2019-07-04T00:52:56Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 135,
              "body": "```suggestion\r\nFor example, distinguishing strings for agents in peer-to-peer IoT device deployments could be MAC addresses. Similarly, distinguishing strings for agents in mesh VM deployments could be namespaces.\r\n```",
              "createdAt": "2019-07-04T00:54:38Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nThe decision to use this field and what it should contain MUST be agreed OOB.\r\n```",
              "createdAt": "2019-07-04T00:54:50Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\r\nNote that, critically, this value is never sent on the wire, as this would identify the client even to passive adversaries.\r\n```",
              "createdAt": "2019-07-04T00:55:21Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 125,
              "body": "This wall of text is sort of difficult to read. Can we move it to a subsection that describes how it's used, with a forward pointer here to that section? For example:\r\n\r\n```suggestion\r\nThe `client_id` is an optional field that is required to be unique for each actor that knows the the EPSK. See section {{client-id-description}} for more details.\r\n```",
              "createdAt": "2019-07-04T00:56:24Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 139,
              "body": "nit: unnecessary empty line ",
              "createdAt": "2019-07-04T00:56:39Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nHowever, if the OOB PSK was established through a protocol, or series of protocols, that provide a continuing security context, then including the channel binding for these contexts, as well as any keys established, binds the security contexts together.\r\n```",
              "createdAt": "2019-07-04T00:57:26Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 144,
              "body": "```suggestion\r\nAs an example, consider chaining together two TLS sessions using OOB PSK importers rather than resumption.\r\n```",
              "createdAt": "2019-07-04T00:57:51Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 145,
              "body": "`exporter_key` is probably confusing since there's already 'exporter_secret' in 1.3 -- maybe rename to `\"my_custom_setup\"`, or something?",
              "createdAt": "2019-07-04T00:59:30Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 145,
              "body": "This feels like it needs to be more precise, especially for this example. Can we add more details here? (What details I am not sure at the moment. I need to chew on this a bit more!)",
              "createdAt": "2019-07-04T01:00:38Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NDI1NTc4",
          "commit": {
            "abbreviatedOid": "a6e76b0"
          },
          "author": "Lekensteyn",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T14:12:07Z",
          "updatedAt": "2019-07-05T14:53:51Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "For the above \"TLS 1.3 mandates that each PSK be associated\", should \"be\" -> \"is\"?\r\nFor this \"does not require they be provisioned\", \"they\" -> \"them to\" or \"these to\"?",
              "createdAt": "2019-07-05T14:12:07Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 116,
              "body": "Nit: missing trailing `;`",
              "createdAt": "2019-07-05T14:17:09Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 155,
              "body": "Some issues:\r\n- This whole text seems rather bloated, can it be written in a more concise way?\r\n- The last sentence is not necessarily true. If a MAC address is used as client identifier, then it will be visible somewhere on the wire.\r\n- The (non-)requirements for \"client_id\" is not explicitly specified. Does it have to be globally unique? What if this \"requirement\" is not satisfied?\r\n\r\nThe Selfie issue occurred because a PSK was reused for a client and server role. What about a simpler solution: require implementations to store the role with the PSK identity? If desired, this role (1 byte) could be explicitly included in the context.",
              "createdAt": "2019-07-05T14:40:35Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 160,
              "body": "I guess you are concerned about a situation where two different key inputs result in the same session keys (and thus the same channel binding)? Then why not define the channel binding as including the hash of the previous transcript?\r\n\r\nRequiring previous keys to be included here might actually weaken security as they would have to be kept around for a longer time. (That could be mitigated by precomputing the context, but that might not always be possible.)",
              "createdAt": "2019-07-05T14:49:00Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 166,
              "body": "The [TLS 1.2 exporter][1] output is derived from the master secret.\r\nThe [TLS 1.3 exporter][2] output is derived from the [early_]exporter_master_secret which is [derived][3] from the Early Secret or Master Secret.\r\n\r\nUnless you do not trust the hash functions, I don't see why adding the master secret would help. Could you clarify this?\r\n\r\n [1]: https://tools.ietf.org/html/rfc5705#section-4\r\n [2]: https://tools.ietf.org/html/rfc8446#section-7.5\r\n [3]: https://tools.ietf.org/html/rfc8446#page-93\r\n",
              "createdAt": "2019-07-05T14:53:45Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTAxNjM2",
          "commit": {
            "abbreviatedOid": "a6e76b0"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T17:44:25Z",
          "updatedAt": "2019-07-05T17:44:25Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "W.r.t. the Selfie issue, including the role was my initial thought, however if you think it through it actually doesn't help at all. Agent 1, acting in its role as Client sends a `ClientHello` with the role \"client\". The attacker reflects the `ClientHello` back at Agent 1. Agent 1, receives the `ClientHello`, and because it expects Agent 2 to use the role \"client\" when it acts as the client, accepts. \r\nThe problem is specifically that both agents act completely identically, so they are indistinguishable. \r\nIn fact, in this configuration the agents don't even know which agent they are. \r\n\r\n1. The text is trying to refute exactly the argument you made. It probably needs to be longer. \r\n\r\n2. I agree that the sentence is overbroad, I'll have to be more precise.\r\n\r\n3. Good catch. The requirements are listed in a previous section, but the link got lost as I shuffled the text around. ",
              "createdAt": "2019-07-05T17:44:25Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTExNTI4",
          "commit": {
            "abbreviatedOid": "a6e76b0"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T18:21:19Z",
          "updatedAt": "2019-07-05T18:21:20Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Correct. \r\nThe reason I don't define the channel binding in that way is because it's neither a sufficient nor a necessary condition, even though including it is a very common design pattern. \r\nA channel binding based solely on the (public) transcript is not necessarily secure, because some security critical parameters, e.g. the keys being used, are secret. \r\nConsider the attack in [Cremers et al.](https://tls13tamarin.github.io/TLS13Tamarin/docs/tls13tamarin.pdf). \r\nThe transcripts of the second session are both identical, but they agree different session keys. \r\n\r\nTranscripts are also not necessary. [Bhargavan et al.](https://www.ndss-symposium.org/wp-content/uploads/2017/09/08_5.pdf) showed that you can build secure channel bindings without using a transcript. They provide a list of what is needed in Section IV. \r\n\r\nI agree that keeping session keys around long term is bad practice, but that isn't the intention here. \r\nThis is for if you want to run a compound protocol, i.e. nest one protocol inside the security context of another.\r\nThe idea is that you run all protocols in quick succession, as if they were one extended protocol. \r\nBecause we are building a nested structure, and you keep session keys until the end of the session, if you want the security context of protocol A nested inside the security context of protocol B, you run B, keeping the keys, then run A, then delete any keys for A, then delete any keys for B. `[ ( ) ]` \r\nThe design intentionally requires you to prove that you have access to all the keys during the establishment of the innermost session. \r\nAccess to the channel binding is insufficient, because channel bindings are designed such that you can make them public without damaging security. \r\nIf you have to keep your channel binding secet it's not a channel binding, it's a key. \r\n\r\nTL;DR: requiring the keys is a necessary condition, the channel binding is insufficient. ",
              "createdAt": "2019-07-05T18:21:20Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDU1MzM4",
          "commit": {
            "abbreviatedOid": "d7dd7c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good revisions! I left some comments and edits to consider.",
          "createdAt": "2019-07-08T17:37:49Z",
          "updatedAt": "2019-07-08T17:57:06Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "The Selfie citation should probably go here.",
              "createdAt": "2019-07-08T17:37:49Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nIf two actors use the same `client_id` this defense may not be effective. \r\n```",
              "createdAt": "2019-07-08T17:37:59Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 143,
              "body": "This is confusing to me. This sentence suggests that including `client_id` is sufficient, whereas the previous sentence seems to contradict it? Does the previous sentence mean to say the following? \r\n\r\n```\r\nIf two actors have the same `client_id` this defense may not be effective.\r\n```\r\n\r\n(The difference being \"have\" vs \"use\")",
              "createdAt": "2019-07-08T17:39:39Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 140,
              "body": "```suggestion\r\nThe `client_id` is an optional field. If present, it MUST be unique for each actor that knows the EPSK.\r\n```",
              "createdAt": "2019-07-08T17:40:00Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nThe Selfie attack {{Selfie}} abuses an underlying assumption of TLS, i.e., that only one client and server know a PSK.\r\n```",
              "createdAt": "2019-07-08T17:40:44Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 146,
              "body": "```suggestion\r\nA pair of agents that both act as both client and server, and use the same PSK in both roles violate this assumption.\r\n```",
              "createdAt": "2019-07-08T17:40:56Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nBecause both clients have identical configurations, an agent acting as a server cannot distinguish between its peer acting as a client, and itself acting as a client.\r\n```",
              "createdAt": "2019-07-08T17:41:56Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 154,
              "body": "This paragraph seems redundant with the prior one. I'd remove it.",
              "createdAt": "2019-07-08T17:42:35Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 158,
              "body": "This paragraph seems... odd. What value does it add? Can we remove it?",
              "createdAt": "2019-07-08T17:43:15Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 160,
              "body": "Hmm, this is a bit vague.  We don't technically hash `client_id` value \"into the binder,\" right? Perhaps:\r\n\r\n```\r\nHashing a distinguishing `client_id` into the imported PSK lets endpoints distinguish between normal and reflected ClientHello messages.\r\n```",
              "createdAt": "2019-07-08T17:47:58Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 160,
              "body": "Can we add a diagram to show how this would work? ",
              "createdAt": "2019-07-08T17:48:09Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 163,
              "body": "The transition here reads strange. Perhaps move these examples to come after the sentence where we say that client_ids must be unique? And replace \"distinguishing strings\" with \"client_ids\"?",
              "createdAt": "2019-07-08T17:49:22Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nNote that, critically, the TLS protocol never sends `client_id` on the wire, as this would identify the client even to passive adversaries.\r\n```",
              "createdAt": "2019-07-08T17:51:10Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            },
            {
              "originalPosition": 174,
              "body": "This sentence is long! Let's break it up. ",
              "createdAt": "2019-07-08T17:55:51Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTI2ODI4",
          "commit": {
            "abbreviatedOid": "d7dd7c9"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:03:17Z",
          "updatedAt": "2019-07-08T20:03:17Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Technically the `client_id` is (symbolically) sent on the wire, as it is included in the PSK binder, however it is blinded by the `epsk`. If it were unblinded but hashed then it could still be used for fingerprinting. ",
              "createdAt": "2019-07-08T20:03:17Z",
              "updatedAt": "2019-07-08T22:18:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMDQ1MDMy",
      "title": "Change binder_key computation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/10",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-31T16:59:59Z",
      "updatedAt": "2019-11-21T05:36:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "55dabb06c2903a3d786a022dbc5cd695adf7df21",
      "headRepository": "jhoyla/draft-ietf-tls-external-psk-importer",
      "headRefName": "imp_binder",
      "headRefOid": "d79f32d12be42f0ec5a0e53e9ede40d04f4c6836",
      "closedAt": "2019-11-21T05:36:45Z",
      "mergedAt": "2019-11-21T05:36:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "215ea8f38492e8f5e104ee9bf5fc1d555479a56e"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in Singapore; will merge and add security considerations motivation in a followup to #23.",
          "createdAt": "2019-11-21T05:36:41Z",
          "updatedAt": "2019-11-21T05:36:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTYwNjgw",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-31T17:15:43Z",
          "updatedAt": "2019-07-31T17:19:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n# Binder Key\r\n```",
              "createdAt": "2019-07-31T17:15:43Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nIn TLS 1.3 the PSK binder key computation is defined as follows:\r\n```",
              "createdAt": "2019-07-31T17:15:59Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 29,
              "body": "nit: should not? Can we state this with any more confidence?",
              "createdAt": "2019-07-31T17:16:26Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 30,
              "body": "This sentence doesn't parse. Can you please rephrase?",
              "createdAt": "2019-07-31T17:16:51Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 31,
              "body": "Hmm... I'm not sure it does. There's nothing stopping someone from deriving a binder key in the same way and using it to encrypt or MAC something. Perhaps simply:\r\n\r\n\"Label differentiation prevents collisions with non-imported external keys.\"",
              "createdAt": "2019-07-31T17:19:09Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 33,
              "body": "This entire list seems unnecessary. Let's remove it.",
              "createdAt": "2019-07-31T17:19:51Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTYzNzkz",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T17:21:49Z",
          "updatedAt": "2019-07-31T17:21:49Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "If I was being sensible / brave / mad I would re-run at least the Tamarin proofs with this change, but other than that I'd be wary of saying anything braver.",
              "createdAt": "2019-07-31T17:21:49Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTY0NTgz",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T17:23:14Z",
          "updatedAt": "2019-07-31T17:23:14Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Ugh, this was a copy paste error. It should read\r\n\"The only change that is not a previously valid TLS 1.3 trace in the change to the `binder_key` computation. We thus mostly focus our attention there.\"",
              "createdAt": "2019-07-31T17:23:14Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTY1NDI2",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T17:24:42Z",
          "updatedAt": "2019-07-31T17:24:42Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I guess that's true, I was thinking in terms of types, so yes you could use it to encrypt but you wouldn't get a valid result. I'll rephrase to something correct in real life :P. ",
              "createdAt": "2019-07-31T17:24:42Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTY1OTM2",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T17:25:34Z",
          "updatedAt": "2019-07-31T17:25:35Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I'm going through the eight security guarantees in order and arguing why this change shouldn't affect them. I should probably say that at the top. ",
              "createdAt": "2019-07-31T17:25:35Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTY3Mjg5",
          "commit": {
            "abbreviatedOid": "e49a80f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T17:28:00Z",
          "updatedAt": "2019-07-31T17:28:00Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "What eight properties? (Either way, I'm not sure it's needed here. Maybe in an appendix if anywhere.)",
              "createdAt": "2019-07-31T17:28:00Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNjk3Njc3",
          "commit": {
            "abbreviatedOid": "d70b56a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-08T16:39:10Z",
          "updatedAt": "2019-08-08T16:58:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "s/securtiy/security/",
              "createdAt": "2019-08-08T16:39:10Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 29,
              "body": "(I also agree it's sort of weird to have a spec say something very vague like this.)",
              "createdAt": "2019-08-08T16:46:34Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 26,
              "body": "Super nitpicky nitpick: there are some `|`s missing in the ASCII diagram. The left vertical line got interrupted in the line wrapping.",
              "createdAt": "2019-08-08T16:56:52Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 7,
              "body": "Does this need `~~~` surrounding the diagram? Ditto with the other one.",
              "createdAt": "2019-08-08T16:57:58Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0NTkxNTgz",
          "commit": {
            "abbreviatedOid": "1cfaa77"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-13T22:35:30Z",
          "updatedAt": "2019-08-13T22:35:30Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n```",
              "createdAt": "2019-08-13T22:35:30Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0NTkxNjYz",
          "commit": {
            "abbreviatedOid": "1cfaa77"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-13T22:35:49Z",
          "updatedAt": "2019-08-13T22:35:50Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nAdding label differentiation prevents collisions with non-imported external keys, because using disjoint contexts in an HKDF to one disjoint ensures key separation.\r\n```",
              "createdAt": "2019-08-13T22:35:49Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0NTkxODcz",
          "commit": {
            "abbreviatedOid": "1cfaa77"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Only a few minor changes before we're good to go!",
          "createdAt": "2019-08-13T22:36:32Z",
          "updatedAt": "2019-08-13T22:36:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzIwNTM4",
          "commit": {
            "abbreviatedOid": "9691dea"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This seems harmless, but it is predicated on a need to separate keys that I don't understand.  Is there more rationale somewhere?",
          "createdAt": "2019-09-03T00:36:56Z",
          "updatedAt": "2019-09-03T00:37:14Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I don't see this as a change, but more of an addition.",
              "createdAt": "2019-09-03T00:36:56Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyOTY1MDUz",
          "commit": {
            "abbreviatedOid": "9691dea"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T12:41:40Z",
          "updatedAt": "2019-09-03T12:41:41Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> This seems harmless, but it is predicated on a need to separate keys that I don't understand. Is there more rationale somewhere?\r\n\r\nThe underlying issue is that without this change you can't distinguish the plain OOB case from the PSK Importer case. \r\nFor example the server could believe it was using an importer PSK, but the client could believe it was using a vanilla OOB key. Because there is no extension in the handshake signaling the use of Importer PSKs explicitly we need to agree the use of Importer keys implicitly. \r\n\r\nI actually think this a weakness of TLS 1.3's OOB keys in general. They should have had a way to agree security context around the establishment of PSKs, in the same way that exporter keys allow us to bind a TLS context into a higher layer protocol. \r\nThis change, in conjunction with PR #12 resolves this issue. \r\nEven if you do not want to change the hash function you can use PSK importers to bind in extra security context, and the key splitting will ensure everything Just Works\u2122 (i.e. prove that the client and server agree on the extra security context). ",
              "createdAt": "2019-09-03T12:41:40Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMDk1MTQ2",
          "commit": {
            "abbreviatedOid": "9691dea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T15:51:59Z",
          "updatedAt": "2019-09-03T15:52:00Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "@jhoyla I think @martinthomson is asking to add rationale for the new label. Perhaps you could summarize this in a single sentence in the PR?",
              "createdAt": "2019-09-03T15:51:59Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxOTYyNTE0",
          "commit": {
            "abbreviatedOid": "8ebc04e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think the text can be simplified a bit. @jhoyla, what do you think?",
          "createdAt": "2019-09-23T18:14:25Z",
          "updatedAt": "2019-09-23T18:17:49Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe `binder_key` is a leaf key. Therefore, changing its computation doesn't affect any other key.\r\n```",
              "createdAt": "2019-09-23T18:14:25Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            },
            {
              "originalPosition": 33,
              "body": "Perhaps a simplification for this and the following two sentences:\r\n\r\n```suggestion\r\nThis new label differentiates non-imported and imported external PSKs. Specifically, a client and server will negotiate use of an external PSK if and only if (a) both endpoints import the PSK or (b) neither endpoint imports the PSK.\r\n```",
              "createdAt": "2019-09-23T18:17:22Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0Mzc3NTg5",
          "commit": {
            "abbreviatedOid": "c6c7104"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Almost there!",
          "createdAt": "2019-09-27T14:51:08Z",
          "updatedAt": "2019-09-27T14:51:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This sentence and the following one are redundant. ",
              "createdAt": "2019-09-27T14:51:08Z",
              "updatedAt": "2019-09-27T15:09:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjQ4ODU5",
          "commit": {
            "abbreviatedOid": "d79f32d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-21T05:36:09Z",
          "updatedAt": "2019-11-21T05:36:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NTczMzkz",
      "title": "Include CTXInfo (\u00e0 la HKDF Kra10).",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/12",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To make external psk importers more featureful it makes sense to take advantage of the HKDF already in use. \r\nBy providing a field for extra context we can avoid protocol layering attacks. \r\nFor example this change allows us to securely bind one TLS session to another, providing layered context.",
      "createdAt": "2019-08-08T13:18:07Z",
      "updatedAt": "2019-08-08T19:47:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "a4da3e03c1ebe9575f5404fd79c5f79a3f7821f1",
      "headRepository": "jhoyla/draft-ietf-tls-external-psk-importer",
      "headRefName": "CTX_Info",
      "headRefOid": "b91a04aca1e1aea75078d4249da9865a9ca94403",
      "closedAt": "2019-08-08T19:47:12Z",
      "mergedAt": "2019-08-08T19:47:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "55dabb06c2903a3d786a022dbc5cd695adf7df21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNjkzMDc1",
          "commit": {
            "abbreviatedOid": "83bd51d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with the suggested name change!",
          "createdAt": "2019-08-08T16:30:32Z",
          "updatedAt": "2019-08-08T16:32:12Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nfrom some other protocol or sequence of protocols, ImportedIdentity.context MUST include a channel binding for the deriving protocols\r\n```",
              "createdAt": "2019-08-08T16:31:06Z",
              "updatedAt": "2019-08-08T17:02:53Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nImportedIdentity.context MUST include the context used to derive the EPSK, if any exists.  If the EPSK is a key derived\r\n```",
              "createdAt": "2019-08-08T16:31:14Z",
              "updatedAt": "2019-08-08T17:02:53Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n       opaque context<0..2^16-1>;\r\n```",
              "createdAt": "2019-08-08T16:31:24Z",
              "updatedAt": "2019-08-08T17:02:53Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n{{!RFC5056}}.  If any secrets are agreed in earlier protocols they SHOULD be included in ImportedIdentity.context [CCB].\r\n```",
              "createdAt": "2019-08-08T16:31:39Z",
              "updatedAt": "2019-08-08T17:02:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNjk1MTQ5",
          "commit": {
            "abbreviatedOid": "83bd51d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! This is *much* more understandable than the previous PR. :-)",
          "createdAt": "2019-08-08T16:34:24Z",
          "updatedAt": "2019-08-08T16:34:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2MDI5MjA0",
      "title": "Selfie",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/13",
      "state": "CLOSED",
      "author": "jhoyla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add text describing the Selfie fix. \r\nRelies on `imp_binders` PR to be effective.",
      "createdAt": "2019-08-09T15:06:08Z",
      "updatedAt": "2019-08-15T12:22:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "55dabb06c2903a3d786a022dbc5cd695adf7df21",
      "headRepository": "jhoyla/draft-ietf-tls-external-psk-importer",
      "headRefName": "Selfie",
      "headRefOid": "0574dbde6c363bbeeb2714e47f9e453ca7a78711",
      "closedAt": "2019-08-15T12:22:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I applied the suggestion in #14. Closing for now!",
          "createdAt": "2019-08-15T12:22:37Z",
          "updatedAt": "2019-08-15T12:22:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0NTkyMDQx",
          "commit": {
            "abbreviatedOid": "0574dbd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Requesting changes since I'm not sure the current text works as a mitigation.",
          "createdAt": "2019-08-13T22:37:03Z",
          "updatedAt": "2019-08-13T22:57:01Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nThe Selfie attack {{Selfie}} relies on a misuse of the PSK interface.  The PSK interface makes the implicit assumption\r\n```",
              "createdAt": "2019-08-13T22:37:03Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nthe PSK is known to two clients and two servers, then implicit PSK authentication is broken.  If two distinct\r\n```",
              "createdAt": "2019-08-13T22:37:33Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\nservers have the same key then they are indistinguishable to the client, and vice versa.  As a mitigation, one\r\n```",
              "createdAt": "2019-08-13T22:37:58Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nservers use unique contexts the Imported PSKs they produce will be cryptographically independent.\r\n```",
              "createdAt": "2019-08-13T22:38:25Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\ncan use imported PSKs with extra context that distiguishes the various actors.  As long as all distinct clients and\r\n```",
              "createdAt": "2019-08-13T22:38:34Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            },
            {
              "originalPosition": 72,
              "body": "So, I'm not sure this works. Let's assume there's two peers -- Alice and Bob, with MAC addresses MA and MB, respectively -- and they have an external PSK k. The text below suggests that Alice will import k1 = KDF(k || MA) (abusing notation for clarity!), and Bob will import k2 = KDF(k || MB). Then assume Alice sends a CH with binder computed using k1 to Bob. Alice will happily accept this CH if reflected back to herself by an attacker, since it only has k1 to verify. In contrast, Bob will fail to verify the binder, since he only has k2! \r\n\r\nI think this needs to do more, and further split k1 into \"read\" and \"write\" roles, and then only use them as such. For example, k1_read = KDF(k || MA || \"read\") and k1_write = KDF(k || MA || \"write\"). Bob does something similar. If Alice only computes binders with the \"write\" key and verifies binder using her \"read\" key, the reflection above won't work.\r\n\r\nAll that said, this is a great amount of complexity that needs to happen inside TLS. What we need is for the PSK to never be used by more than one entity for different roles. Can we simply outlaw that with a nasty MUST? (\"Nodes MUST NOT use the same imported PSKs for different roles\".) @davidben, what do you think?",
              "createdAt": "2019-08-13T22:56:44Z",
              "updatedAt": "2019-08-13T22:57:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1MTM5NTM3",
          "commit": {
            "abbreviatedOid": "0574dbd"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-14T20:43:59Z",
          "updatedAt": "2019-08-14T20:43:59Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I'm not sure the \"read\" or \"write\" roles quite make sense. The PSK sender and verifier need to use the same key, so the server needs to flip. That means one of the two keys just won't be used.\r\n\r\nI also worry focusing on the MAC address will lead folks to thinking MAC addresses are somewhat special. Presumably you want the names of the node's roles in the actual application protocol. If your protocol identifies by MAC addresses, cool. If not, you want to use something else.\r\n\r\nI took a stab at revised text. How does this look:\r\n\r\n```\r\n# Addressing Selfie\r\n\r\nThe Selfie attack {{Selfie}} relies on a misuse of the PSK interface.\r\nThe PSK interface makes the implicit assumption that each PSK\r\nis known only to one client and one server. If multiple clients or\r\nmultiple servers with distinct roles share a PSK, TLS only\r\nauthenticates the entire group. A node successfully authenticates\r\nits peer as being in the group whether the peer is another node or itself.\r\n\r\nApplications which require authenticating finer-grained roles while still\r\nconfiguring a single shared PSK across all nodes can resolve this\r\nmismatch either by exchanging roles over the TLS connection after\r\nthe handshake or by incorporating the roles of both the client and server\r\ninto the imported PSK context string. For instance, if an application\r\nidentifies each node by MAC address, it could use the following context string.\r\n\r\n~~~\r\n  struct {\r\n    opaque client_mac<0..2^16-1>;\r\n    opaque server_mac<0..2^16-1>;\r\n  } Context;\r\n~~~\r\n\r\nIf an attacker then redirects a ClientHello intended for one node to a different\r\nnode, the receiver will compute a different context string and the handshake\r\nwill not complete.\r\n\r\nNote that, in this scenario, there is still a single shared PSK across all nodes,\r\nso each node must be trusted not to impersonate another node's role.\r\n```",
              "createdAt": "2019-08-14T20:43:59Z",
              "updatedAt": "2019-08-14T20:43:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1MzE4Nzg3",
          "commit": {
            "abbreviatedOid": "0574dbd"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-15T08:40:48Z",
          "updatedAt": "2019-08-15T08:40:49Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I think my original suggestion was made clearly enough. The client would use the client MAC and the server would _also_ use the client MAC. However I think including both MAC addresses is probably better. I won't have my laptop 'til Sunday but @davidben's change looks good to me.\r\nMaybe say something about privacy in the non DH case too?",
              "createdAt": "2019-08-15T08:40:48Z",
              "updatedAt": "2019-08-15T08:40:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA3Njg2MjA5",
      "title": "Add text on addressing Selfie.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/14",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Migrated text from #13.",
      "createdAt": "2019-08-15T12:22:11Z",
      "updatedAt": "2019-08-15T12:22:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "55dabb06c2903a3d786a022dbc5cd695adf7df21",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/selfie",
      "headRefOid": "6a8fecbfd2baa5ec9c05da75aebd08038d9f0dbb",
      "closedAt": "2019-08-15T12:22:20Z",
      "mergedAt": "2019-08-15T12:22:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "861417d9df9c2e00f0a2b00757c0f5f896823ebb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1NzAyNDMy",
      "title": "Compact and future-proof the ImportedIdentity structure",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/17",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Replace the variable length info string with a 2-octet protocol version\r\ncodepoint. Replace HashAlgorithm with a KDF identifier and corresponding\r\nregistry. Add HKDF-SHA256 and HKDF-SHA512 to the KDF identifier table.\r\n\r\nSee #15 for discussion around this change.",
      "createdAt": "2019-09-09T20:28:36Z",
      "updatedAt": "2019-09-26T22:26:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "861417d9df9c2e00f0a2b00757c0f5f896823ebb",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/collapse-context",
      "headRefOid": "a9c6273e965db813f75f54260ee84a0f569c4366",
      "closedAt": "2019-09-26T22:26:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson I pulled out the protocol code point change into #18, since it can stand on its own for now. I think we need to have a larger discussion about the KDF proposal. I'll take that to the list!",
          "createdAt": "2019-09-14T14:24:33Z",
          "updatedAt": "2019-09-14T14:24:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODc1NzM5",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is the right change for sure.  Thanks for putting it together.\r\n\r\nMost of my comments are editorial or only partly related.",
          "createdAt": "2019-09-10T02:22:14Z",
          "updatedAt": "2019-09-10T02:36:56Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I think that it might make sense to use the phrase \"target protocol\" and \"target KDF\" or something similar here.  There's a risk of having this confused in some way with the KDF that is being applied.",
              "createdAt": "2019-09-10T02:22:15Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 67,
              "body": "Is context something that you would use in derivation, or something you would do to further separate outputs based on context?  I tend to see this context as a way of taking an EPSK and applying it for a specific situation, not a way of providing information about how the EPSK originated (that would be baked into its identifier).\r\n\r\nSay that I wanted to build a system that took Russ' pre-shared key + certificate idea.  I would have a group key agreement (or dissemination) protocol that produced a tuple of (key, identifier, KDF) which would form the EPSK.  In binding this into a TLS connection, I might want to take a hash of that protocol transcript into `context`, as you describe here.  But that doesn't really distinguish this usage from other potential uses in other protocols.  The target protocol and KDF help in the case that this is TLS vs. something completely different, but what if you want to use this for different TLS-using applications (HTTP and IMAP for example) and you want good key separation between those applications.  That's what I imagined this `context` field would be used for.\r\n\r\nMaybe the right answer is to have multiple EPSK tuples produced from the source protocol, but that might not always be possible.\r\n\r\nEither way, I think that you need to be clearer about whether `context` is for better distinguishing the input to this process, or in further distinguishing outputs.",
              "createdAt": "2019-09-10T02:24:23Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 69,
              "body": "Shouldn't secrets be folded into the PSK?",
              "createdAt": "2019-09-10T02:32:20Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 75,
              "body": "Might want to note that DTLS 1.2 uses 0x0303 rather than the ones-complement identification.",
              "createdAt": "2019-09-10T02:33:06Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nDifferentiating EPSK by ImportedIdentity.kdf ensures that each imported PSK is only used with at most one\r\n```",
              "createdAt": "2019-09-10T02:33:32Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 103,
              "body": "This is another example of where the KDF is confusing.  You should use something like \"target KDF\" and \"EPSK KDF\" to distinguish them.",
              "createdAt": "2019-09-10T02:34:31Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 103,
              "body": "Not sure how happy I am with the SHA-256 thing still.  I don't think that you need this sentence now based on the definition of the KDF functions.\r\n\r\n```suggestion\r\nbound to ImportedIdentity.kdf.\r\n```",
              "createdAt": "2019-09-10T02:35:16Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            },
            {
              "originalPosition": 146,
              "body": "I assume that you plan to sort out which of this and HPKE will have the privilege of establishing this registry.  It doesn't make sense to duplicate effort.",
              "createdAt": "2019-09-10T02:36:01Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDM5MTEx",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:13:36Z",
          "updatedAt": "2019-09-10T21:13:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Good suggestion! I'll work that in somehow.",
              "createdAt": "2019-09-10T21:13:36Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDM5NDcx",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:14:19Z",
          "updatedAt": "2019-09-10T21:14:19Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "That sounds reasonable. I'll probably defer this to a separate cleanup issue for @jhoyla. He can better articulate the need for `context`. (In most cases, it will be empty, and I'll add that here.)",
              "createdAt": "2019-09-10T21:14:19Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQwMzMw",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:16:03Z",
          "updatedAt": "2019-09-10T21:16:04Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "As far as I know, and @jhoyla should feel free to correct me, this is the \"usual\" (for some definition of usual) channel binding mechanism. That is, add a slot to put in additional channel binding blobs. In principle, I agree that it could (should?) be included in the external PSK, as that seems morally superior, but I defer to the channel binding expert. :-)",
              "createdAt": "2019-09-10T21:16:03Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQwMzc5",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:16:09Z",
          "updatedAt": "2019-09-10T21:16:09Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "~\ud83d\udc4d good call~\r\n\r\nI misread -- I assume you meant 0xFEFD here, and will specify that.",
              "createdAt": "2019-09-10T21:16:09Z",
              "updatedAt": "2019-09-14T13:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQwNDE4",
          "commit": {
            "abbreviatedOid": "46089b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:16:13Z",
          "updatedAt": "2019-09-10T21:16:14Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-09-10T21:16:14Z",
              "updatedAt": "2019-09-10T21:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQwNTk5",
          "commit": {
            "abbreviatedOid": "a9c6273"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:16:37Z",
          "updatedAt": "2019-09-10T21:16:37Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Yep, will do!",
              "createdAt": "2019-09-10T21:16:37Z",
              "updatedAt": "2019-09-10T21:16:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQxMDMw",
          "commit": {
            "abbreviatedOid": "a9c6273"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:17:33Z",
          "updatedAt": "2019-09-10T21:17:34Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Well, we need a default in case there's not one tied to `epsk`. I'll update this to be HKDF-SHA256.",
              "createdAt": "2019-09-10T21:17:33Z",
              "updatedAt": "2019-09-10T21:17:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2NDQxMDkz",
          "commit": {
            "abbreviatedOid": "a9c6273"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-10T21:17:43Z",
          "updatedAt": "2019-09-10T21:17:43Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Correct :)",
              "createdAt": "2019-09-10T21:17:43Z",
              "updatedAt": "2019-09-10T21:17:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg5OTAwMzc0",
          "commit": {
            "abbreviatedOid": "a9c6273"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-18T13:03:19Z",
          "updatedAt": "2019-09-18T13:03:20Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "The idea is that this says that this field lists everything that came before, i.e. the \"history\" of the KDF. The protocol field is for distinguishing the intended future use of the key, although maybe we need to make that more specific if you need to distinguish TLS for HTTP from TLS for IMAP.\r\n\r\nIf a commitment to future usage happens in a previous step that should appear in the transcript I guess? \r\n\r\nAs a side note: If you're doing a group key agreement and then a PSK importer a simple transcript hash might not be sufficient, because the recipient doesn't know which of the group participants it is speaking to. You would need to include the client's group id also, and even then you need to trust group participants to be honest. ",
              "createdAt": "2019-09-18T13:03:20Z",
              "updatedAt": "2019-09-18T13:03:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg5OTA5MTQx",
          "commit": {
            "abbreviatedOid": "a9c6273"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-18T13:16:06Z",
          "updatedAt": "2019-09-18T13:16:07Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "So this is based on the contributive channel bindings from [BDP15](https://www.ndss-symposium.org/wp-content/uploads/2017/09/08_5.pdf). Basically for the authentication properties of outer layers to propagate inwards each layer has to prove it still has access to the previously established secrets. So yes, they should already be folded into the PSK, but if the PSK is generated by a long chain of protocols this recommits the client and server to all those sessions individually. \r\nImagine that there were some attack on the layer immediately preceding the PSK importer that leaked the EPSK. By re-committing to the previously established keys even knowing the EPSK is insufficient for the attacker to mount an attack. ",
              "createdAt": "2019-09-18T13:16:07Z",
              "updatedAt": "2019-09-18T13:16:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3NTY0NTU1",
      "title": "Make ImportedIdentities target protocol versions and KDFs",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, remove PSK identity encryption sketch. This was underspecified and\r\ncan always be done in a separate draft if desired.\r\n\r\ncc @martinthomson",
      "createdAt": "2019-09-14T14:23:18Z",
      "updatedAt": "2019-09-28T00:25:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "861417d9df9c2e00f0a2b00757c0f5f896823ebb",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/label-to-protocol",
      "headRefOid": "8aaf99c63f500d7a36f0ce2d7e09b721bc12aa80",
      "closedAt": "2019-09-28T00:25:09Z",
      "mergedAt": "2019-09-28T00:25:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1a44da79e08f7e4ff28c60f2cde255b7f59b587e"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Note, we might want to simply consider merging `target_protocol` and `target_kdf` into the same field, since we have the registry. That'd save us two bytes. It seems to boil down to whether keeping protocol and KDF separate is better (long term) than merging them. I'm not sure what's the best answer there.",
          "createdAt": "2019-09-26T17:58:44Z",
          "updatedAt": "2019-09-26T17:58:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzOTMwMzUz",
          "commit": {
            "abbreviatedOid": "d4f3755"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T18:46:38Z",
          "updatedAt": "2019-09-26T20:31:46Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "What is the hash function associated with TLS12_PRF_MD5SHA1? Is it MD5SHA1(x) := MD5(x) || SHA1(x)? If so, that should probably be written explicitly.",
              "createdAt": "2019-09-26T18:46:38Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 214,
              "body": "Nitpick: This is the TLS 1.0/1.1 PRF and doesn't actually exist in TLS 1.2.",
              "createdAt": "2019-09-26T18:48:32Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 212,
              "body": "Does this one actually exist? TLS 1.0/1.1 use an MD5/SHA1 combo and TLS 1.2 only ever uses SHA256 and SHA384. To that end, we should probably define `TLS12_PRF_SHA384`.",
              "createdAt": "2019-09-26T18:50:24Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 216,
              "body": "Prior to this PR, we had exactly one more for TLS 1.2 and earlier, to reflect their existing lack of key separation. Is the thinking that we'll retroactively add in some key separation into TLS 1.2? Protocol-wise, that seems doable enough. PSKs are negotiated after and version cipher suites in TLS 1.2, the negotiation is extra straightforward. But I think we should describe this explicitly.\r\n\r\nWe also have this sentence in the introduction, which doesn't quite contradict it but may need some follow-up text:\r\n\r\n> TLS 1.2 {{!RFC5246}}, in contrast, has no such requirement, as a PSK may be used with any hash algorithm and the TLS 1.2 PRF.\r\n\r\nThe other consideration is what we're keeping TLS 1.2 compatibility around for. These are the scenarios I can imagine:\r\n\r\n1. This is a new application with no legacy TLS 1.2 PSK deployment at all. It can just assume TLS 1.3+.\r\n2. This is a new application with no legacy TLS 1.2 PSK deployment, but for some odd reason it can't just assume TLS 1.3+?\r\n3. This is an application which previously used TLS 1.2 PSKs. It wishes to smooth migrate to TLS 1.3, which means dual-1.2/1.3 endpoints must exist for a period of time.\r\n4. Same as above, but this time the underlying TLS library wishes to enable TLS 1.3 by default, so no API calls to the TLS stack may change.\r\n\r\nCase 1 is easy. It just doesn't care about TLS 1.2 logic in this draft, either before or after this PR.\r\n\r\nCase 2 is odd. It can use the TLS 1.2 logic in this draft. Before this PR is definitely fine as it requires no new TLS 1.2 behavior. After this PR may be tricky, depending on exactly why you can't assume TLS 1.3. If it's because, say, you need to run on an older version of some OS without TLS 1.3, you're limited by what the older TLS 1.2 API exposed. That may or may not be sufficient for this scheme. (E.g. OpenSSL does some callback thing, so you might be able to implement it?? Not sure. But declaratively configuring a set of PSKs won't know to match the KDF.) If you need TLS 1.2 but are able to make code changes to your TLS 1.2 implementation, I suppose after this PR is fine, though I'm confused why you don't use your code change powers to get TLS 1.3.\r\n\r\nCase 3 also isn't helped by this draft, before or after the PR. The existing TLS 1.2 PSK endpoints don't know how to do the IPSK derivation, so, one way or another, the dual-1.2/1.3 endpoints need to speak the old-style derivation at TLS 1.2, not the new style. Depending on how exactly the PSKs are configured, one strategy is to simply configure two separate PSKs, one legacy for TLS 1.2 and one new for TLS 1.3+. If that's not an option and you truly only get one root secret, you are sad. You could pass the same root secret into the legacy and modern path, at the cost of some cross-protocol risk. That's the problem I was trying to address [here](https://tools.ietf.org/html/draft-davidben-tls-universal-psk-00#section-3).\r\n\r\nCase 4 is a harder version of case 3. The library's options are either to say, as a compatibility hack, disable TLS 1.3 for applications that called the `SetTLS12PreSharedKey()` function, or you've got the \"one root secret\" problems above.",
              "createdAt": "2019-09-26T20:27:47Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzOTg4NDIw",
          "commit": {
            "abbreviatedOid": "d4f3755"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T20:36:16Z",
          "updatedAt": "2019-09-26T20:36:16Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Yep! I can add a column to the table indicating that. ",
              "createdAt": "2019-09-26T20:36:16Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzOTg4Njkx",
          "commit": {
            "abbreviatedOid": "d4f3755"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T20:36:44Z",
          "updatedAt": "2019-09-26T20:36:44Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "This is me being lazy :) I can make it `TLS10_PRF_MD5SHA1`.",
              "createdAt": "2019-09-26T20:36:44Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzOTg4ODQ1",
          "commit": {
            "abbreviatedOid": "d4f3755"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T20:37:00Z",
          "updatedAt": "2019-09-26T20:37:00Z",
          "comments": [
            {
              "originalPosition": 212,
              "body": "Nope -- we can remove it, and SHA384!",
              "createdAt": "2019-09-26T20:37:00Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDA3OTcy",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T21:14:42Z",
          "updatedAt": "2019-09-26T21:14:43Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "I agree with your points above. It seems to me that the most realistic case is (1), and, at that point, you might as well just prohibit importing for TLS 1.2 and prior versions. That lets us drop a lot of cruft. (I applied that change in the latest update!)",
              "createdAt": "2019-09-26T21:14:42Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDE1Njk5",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T21:31:37Z",
          "updatedAt": "2019-09-26T21:53:54Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I don't think that you need the parenthetical here any more.\r\n\r\nAlso, you should point out that imported PSKs and non-imported PSKs are distinguished by having different identifiers.  It seems obvious, but we know how little that matters when people are looking to play dumb.",
              "createdAt": "2019-09-26T21:31:37Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 82,
              "body": "I think that you should drop the \"hash is undefined\" piece.  There is no reason to have that.  These are for exclusive use and provision of the key can just assume a default hash function if they want to avoid the overhead of having to say \"SHA-256\" every time.",
              "createdAt": "2019-09-26T21:34:07Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 80,
              "body": "I think that you want a term for the PSK that you provision (this one) AND the PSK that you use with the target protocol and KDF.  You don't seem to have the latter, but I think that you are talking imported PSK (IPSK), right?",
              "createdAt": "2019-09-26T21:36:05Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 96,
              "body": "and a hash function.",
              "createdAt": "2019-09-26T21:37:46Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 116,
              "body": "Is this structure what would be included in the TLS handshake as a PSK ID?",
              "createdAt": "2019-09-26T21:39:01Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 109,
              "body": "Really, why not uint16?  In my opinion, the use of an array for TLS versions was a terrible idea, don't repeat that.  People will start to think that each uint8 has semantics on its own and then you will never be able to change those bits without some sort of misinterpretation.",
              "createdAt": "2019-09-26T21:39:10Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 134,
              "body": "This last bit is the kicker for using ImportedIdentity in a handshake.  We should include those secrets in the derivation of the base key, and we might use those secrets in the derivation of the context, but we shouldn't be transmitting them.",
              "createdAt": "2019-09-26T21:43:10Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\nuse 0x0304. Note that this means future versions of TLS will increase the number of PSKs\r\n```",
              "createdAt": "2019-09-26T21:43:53Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 140,
              "body": "Is this the on-wire version number or the abstract version number?\r\n\r\nWe identify DTLS 1.3 the same as TLS 1.3, with 0x0304, but we identity DTLS 1.2 in two ways: either 0x0303 or 0xfdfd.  I'm sure people will want to know which is used here.\r\n\r\n```suggestion\r\nPSK is being imported. For example, TLS 1.3 {{!RFC8446}} and QUICv1 {{!QUIC=I-D.ietf-quic-transport}}\r\n```",
              "createdAt": "2019-09-26T21:44:43Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 155,
              "body": "This suddenly assumes that the target KDF has a hash function.  You might say that this value is defined by the target KDF, and for those that are hash-based it is the length of the hash function output.",
              "createdAt": "2019-09-26T21:46:45Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 157,
              "body": "Paragraph break.\r\n\r\n```suggestion\r\n\r\nThe hash function used for HKDF {{!RFC5869}} is that which is associated with the external PSK.\r\n```",
              "createdAt": "2019-09-26T21:47:08Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 159,
              "body": "```suggestion\r\nis specified, SHA-256 MUST be used. Diversifying EPSK by ImportedIdentity.target_kdf ensures\r\n```",
              "createdAt": "2019-09-26T21:48:00Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 171,
              "body": "```suggestion\r\nEndpoints generate an Imported PSK for each target KDF they support. For example, importing a key for\r\n```\r\n\r\nI don't think that you want a MUST here.  If I don't *want* to use this EPSK with a given KDF, I shouldn't be forced to.  For instance, if I have an EPSK that is \"strong\", I might not want to use it with a weaker KDF and fall back to ECDH instead.  That sounds crazy now that I write it down, but I don't think we can proscribe that behaviour.",
              "createdAt": "2019-09-26T21:50:58Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 204,
              "body": "MAY?\r\n\r\n```suggestion\r\nthey remove the corresponding KDF from the set of target KDFs used for importing keys.\r\n```",
              "createdAt": "2019-09-26T21:52:01Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 205,
              "body": "\"concrete\"?\r\n\r\n```suggestion\r\nThis does not affect the KDF operation used to derive Imported PSKs.\r\n```",
              "createdAt": "2019-09-26T21:52:24Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 268,
              "body": "See above regarding the use of tuples to identify things.",
              "createdAt": "2019-09-26T21:52:51Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            },
            {
              "originalPosition": 276,
              "body": "You can use ranges: 0x0000-0xfeff and 0xff00-0xffff.",
              "createdAt": "2019-09-26T21:53:23Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDI4MzYy",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:02:12Z",
          "updatedAt": "2019-09-26T22:02:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "That seems reasonable to me. Dropped!",
              "createdAt": "2019-09-26T22:02:12Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDI5MjI0",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:04:22Z",
          "updatedAt": "2019-09-26T22:04:23Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "That seems reasonable. The parenthetical meant to make it painfully obvious that both sides need to import to use an external PSK. Replacing it with the suggested \"non-imported and imported identities are different\" text does the trick, too!",
              "createdAt": "2019-09-26T22:04:23Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDI5Mzg1",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:04:56Z",
          "updatedAt": "2019-09-26T22:04:56Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Yep! I'll add an Imported PSK definition.",
              "createdAt": "2019-09-26T22:04:56Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDI5ODU3",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:06:14Z",
          "updatedAt": "2019-09-26T22:06:15Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "That's covered in the remainder of this sentence.",
              "createdAt": "2019-09-26T22:06:14Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDI5OTA2",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:06:21Z",
          "updatedAt": "2019-09-26T22:06:21Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "Yep! I'll spell that out clearly.",
              "createdAt": "2019-09-26T22:06:21Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMwNDU1",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:07:55Z",
          "updatedAt": "2019-09-26T22:07:55Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "This should be for each ciphersuite. I'll drop the normative MUST and swap \"for each target KDF\" with \"for each offered ciphersuite\". (One shouldn't use a PSK that won't work with a ciphersuite offered on the wire.)",
              "createdAt": "2019-09-26T22:07:55Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxMTc3",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:09:53Z",
          "updatedAt": "2019-09-26T22:09:54Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Will fix!",
              "createdAt": "2019-09-26T22:09:53Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxMTky",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:09:57Z",
          "updatedAt": "2019-09-26T22:09:58Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Will fix!",
              "createdAt": "2019-09-26T22:09:58Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxMjQy",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:10:07Z",
          "updatedAt": "2019-09-26T22:10:08Z",
          "comments": [
            {
              "originalPosition": 268,
              "body": "Yep, good call. I'll fix it.",
              "createdAt": "2019-09-26T22:10:08Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxMjg2",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:10:16Z",
          "updatedAt": "2019-09-26T22:10:16Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Thanks -- will fix!",
              "createdAt": "2019-09-26T22:10:16Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxNDA2",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:10:36Z",
          "updatedAt": "2019-09-26T22:10:37Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I only went with it for consistency with CipherSuite. I'm fine with uint16. I'll make that change.",
              "createdAt": "2019-09-26T22:10:36Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxNDky",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:10:53Z",
          "updatedAt": "2019-09-26T22:10:54Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Will fix!",
              "createdAt": "2019-09-26T22:10:54Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxODk4",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:11:58Z",
          "updatedAt": "2019-09-26T22:11:59Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "This is the on-wire version number. (I left out DTLS since DTLS 1.3 uses 0x0304 and I removed import support for (D)TLS 1.2.)",
              "createdAt": "2019-09-26T22:11:58Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMxOTcw",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:12:12Z",
          "updatedAt": "2019-09-26T22:12:12Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-09-26T22:12:12Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDMyNjU3",
          "commit": {
            "abbreviatedOid": "ab14e05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:14:12Z",
          "updatedAt": "2019-09-26T22:14:13Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I'm just removing that sentence (for now).",
              "createdAt": "2019-09-26T22:14:12Z",
              "updatedAt": "2019-09-26T22:24:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MDM2MjMx",
          "commit": {
            "abbreviatedOid": "8aaf99c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-26T22:25:51Z",
          "updatedAt": "2019-09-26T22:25:51Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Fixed!",
              "createdAt": "2019-09-26T22:25:51Z",
              "updatedAt": "2019-09-26T22:25:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0NTY3MDE2",
          "commit": {
            "abbreviatedOid": "8aaf99c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-27T21:13:37Z",
          "updatedAt": "2019-09-27T21:13:38Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Does this text need to be tweaked if we believe EPSKs can't be used with TLS 1.2 at all?",
              "createdAt": "2019-09-27T21:13:37Z",
              "updatedAt": "2019-09-27T21:13:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0NTkzMzE4",
          "commit": {
            "abbreviatedOid": "8aaf99c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-27T22:43:10Z",
          "updatedAt": "2019-09-27T22:43:11Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Hmm, I don't think so? What did you have in mind?",
              "createdAt": "2019-09-27T22:43:11Z",
              "updatedAt": "2019-09-27T22:43:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyMzY1NjU3",
      "title": "Change category from Experimental to Standards Track.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/19",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was an oversight. Closes #11.",
      "createdAt": "2019-09-28T00:31:07Z",
      "updatedAt": "2019-10-02T12:01:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "1a44da79e08f7e4ff28c60f2cde255b7f59b587e",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/category",
      "headRefOid": "976c8ef92ffb8e7082c12f185c51215c8a062c47",
      "closedAt": "2019-10-02T12:01:09Z",
      "mergedAt": "2019-10-02T12:01:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a18f99acbd572b894d6254f71d7b95b1cf05e7a6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk1MTcyNDM3",
          "commit": {
            "abbreviatedOid": "976c8ef"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "rubber stamp lgtm",
          "createdAt": "2019-09-30T18:37:49Z",
          "updatedAt": "2019-09-30T18:37:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk2MDcwMzUx",
          "commit": {
            "abbreviatedOid": "976c8ef"
          },
          "author": "seanturner",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-02T08:04:05Z",
          "updatedAt": "2019-10-02T08:04:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0NDAyNDE0",
      "title": "Add some security considerations text",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/21",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-03T20:50:18Z",
      "updatedAt": "2019-10-11T16:47:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "a18f99acbd572b894d6254f71d7b95b1cf05e7a6",
      "headRepository": "chris-wood/draft-ietf-tls-external-psk-importer",
      "headRefName": "security-goals",
      "headRefOid": "6943ad61b4f233fc685efbe571c20ce612eb49d1",
      "closedAt": "2019-10-11T16:47:23Z",
      "mergedAt": "2019-10-11T16:47:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d4a50e39ab8600a19fa780603c115dd0b4c1d025"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MTQ3MDUx",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-03T20:57:35Z",
          "updatedAt": "2019-10-03T20:57:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NDg1MjIz",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "jhoyla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T13:47:01Z",
          "updatedAt": "2019-10-04T13:59:13Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "`s/step/steps/`",
              "createdAt": "2019-10-04T13:47:02Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            },
            {
              "originalPosition": 31,
              "body": "\"Specifically the uncompromised protocol execution proves that all the other protocols bound to it are authentic.\"\r\nShould we mention that some authentication protocols only authenticate earlier protocols, and some only authenticate later ones? This fact is derivable from the reference, but is not explicitly mentioned. ",
              "createdAt": "2019-10-04T13:53:06Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            },
            {
              "originalPosition": 20,
              "body": "Is there a distinction to be made between goals of the protocol and the properties we claim it achieves?\r\nI would say preventing IKM reuse is a goal, but not a property. The property is key separation by KDF. \r\nMaybe this is unnecessarily specific. ",
              "createdAt": "2019-10-04T13:54:22Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            },
            {
              "originalPosition": 34,
              "body": "The context is more about where the key came from than where it is going. \r\n\"corresponding context about how the PSK was derived.\"",
              "createdAt": "2019-10-04T13:58:50Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NzU1MDE3",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T23:19:08Z",
          "updatedAt": "2019-10-04T23:19:08Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Hmm... we use `context` for selfie mitigations, which describe where it's going, right? It seems like to can go both ways.",
              "createdAt": "2019-10-04T23:19:08Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NzU1MDc3",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T23:19:30Z",
          "updatedAt": "2019-10-04T23:19:30Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "It's probably best to keep them separate, yeah. Good suggestion! I'll try and clear this up.",
              "createdAt": "2019-10-04T23:19:30Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NzU1MjEy",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T23:20:25Z",
          "updatedAt": "2019-10-04T23:20:25Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Hmm, is that detail relevant here? (I don't think so, but you are the expert!)",
              "createdAt": "2019-10-04T23:20:25Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NzU1NTcz",
          "commit": {
            "abbreviatedOid": "85d8883"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T23:22:30Z",
          "updatedAt": "2019-10-04T23:22:30Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "How about step(s)?",
              "createdAt": "2019-10-04T23:22:30Z",
              "updatedAt": "2019-10-04T23:23:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3MTc1ODI0",
      "title": "Addressing selfie attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/22",
      "state": "CLOSED",
      "author": "ms-s",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Text on addressing Selfie attack based on contributions by Tuomas Aura and Mohit Sethi.",
      "createdAt": "2019-10-11T12:27:00Z",
      "updatedAt": "2019-11-21T02:36:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "a18f99acbd572b894d6254f71d7b95b1cf05e7a6",
      "headRepository": "ms-s/draft-ietf-tls-external-psk-importer",
      "headRefName": "master",
      "headRefOid": "fa99cc02dcddcab2b297f730f9d8009ab5b85388",
      "closedAt": "2019-11-21T02:36:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ms-s",
          "authorAssociation": "NONE",
          "body": "I understand the need to simplify the text. However, external PSKs are (and will continue to be) used in many different settings. Please have a look at \"Continuing to reflect on TLS 1.3 with external PSK\" by Akhmetzyanova et al. : https://eprint.iacr.org/2019/421 which discusses the various applications of external PSKs in IoT and group chats. \r\n\r\nThe current text does not try to fix attacks originating from malicious insiders in a group (and I don't think that this draft is the right place to do that). However, the current text does fix selfie (and other re-routing attacks) with minimal requirements from implementations. \r\n\r\nIf there is certain sections of the text that can be improved/simplified, I can certainly make changes. But simply saying that the roles need to be unique will not prevent implementations from doing otherwise. Besides, they are important enough use-cases that we should fix the attacks for them here. ",
          "createdAt": "2019-10-29T11:25:50Z",
          "updatedAt": "2019-10-29T11:25:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ms-s I don\u2019t follow. As you say, no amount of text will prevent implementations from doing the wrong thing. All we can do is offer guidance, and our guidance is that identifiers be unique. Your proposed text does not add anything new beyond this point. Thus, I propose replacing this PR with a much smaller one wherein we simply state, as an addendum to the current text, that identifiers are unique. \r\n",
          "createdAt": "2019-10-29T12:44:39Z",
          "updatedAt": "2019-10-29T12:44:39Z"
        },
        {
          "author": "ms-s",
          "authorAssociation": "NONE",
          "body": "@chris-wood in your first comment, you said that you only want to make the roles unique (i.e. a client cannot also be a server with the same PSK). This is not the same as what you say in your second comment: you want to make the identifiers unique. Mandating the roles to be unique would bar several use-cases such as group chat described by Akhmetzyanova et al.\r\n\r\nI am with you on mandating unique identifiers. But the text needs to take into account parallel sessions. Feng in his email highlights if (https://mailarchive.ietf.org/arch/msg/tls/F7kpGoIR7Ykkqsbt3WbmuIfr4hI) also stated \"I\u00b9m not sure how TLS PSK deals with the case of having parallel key exchange sessions between two nodes. If that\u00b9s allowed, and the same \u00b3context field\u00b2 is used in the parallel sessions, there might still be a possible UKS attack. Either the parallel sessions are disabled, or if they are allowed, additional context should be added to ensure the identities of the two nodes remain unique even within parallel sessions.\" This is why the pull request says \"it is sufficient to check that the identifier of the other endpoint in context is not equal to any of one\u2019s own identifiers.\". \r\n\r\nIt is also important to highlight that Selfie attacks can be caused by someone who doesn't know the PSK. Christian Huitema had at least understood that Selfie attacks can only be caused by a malicious group member. This is why the text says \"but a malicious non-member can reroute handshakes between honest group members to connect them in unintended ways\".\r\n\r\nI understand that this draft should not be dominated by fixing Selfie attacks. It would be nice if you could point out which parts of the text bother you. I can take another stab at improving that. And it is worth considering if this draft should update 8446.",
          "createdAt": "2019-10-29T15:26:35Z",
          "updatedAt": "2019-10-29T15:26:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood in your first comment, you said that you only want to make the roles unique (i.e. a client cannot also be a server with the same PSK). This is not the same as what you say in your second comment: you want to make the identifiers unique. \r\n\r\nAh, forgive me for sloppy notation. I'm referring to the identity of the peer, which, in the current text, is referred to as their role. \r\n\r\nTo be clear, here's what I'm suggesting:\r\n\r\n```\r\nApplications which require authenticating finer-grained roles while still configuring a single shared PSK across all nodes can resolve this mismatch either by exchanging roles over the TLS connection after the handshake or by incorporating the unique roles (or identities) of both the client and server into the IPSK context string. \r\n```\r\n\r\nIt seems this captures precisely what you're after. Do you disagree? If not, what's missing? \r\n\r\nI think anything more is an application decision that's out of scope for this draft since, IMO, the Selfie \"attack\" is truly a misconfiguration issue. \r\n\r\n> And it is worth considering if this draft should update 8446.\r\n\r\nI do not think an update to 8446 is needed. ",
          "createdAt": "2019-10-29T20:59:47Z",
          "updatedAt": "2019-10-29T20:59:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson, what do you think here?",
          "createdAt": "2019-11-11T02:19:33Z",
          "updatedAt": "2019-11-11T02:19:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Rejecting this PR based on discussion in Singapore.",
          "createdAt": "2019-11-21T02:36:05Z",
          "updatedAt": "2019-11-21T02:36:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NzkyNjU4",
          "commit": {
            "abbreviatedOid": "fa99cc0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think all of this new text can be replaced by clarifying that the role information need be unique in the existing text. Can we just do that instead?",
          "createdAt": "2019-10-24T18:52:57Z",
          "updatedAt": "2019-10-24T18:52:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0Njc1Mjk2",
          "commit": {
            "abbreviatedOid": "fa99cc0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-11T02:58:50Z",
          "updatedAt": "2019-11-11T03:51:56Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "This implies that these values are signaled, but it's not clear where that signaling would occur.  So I'm struggling to understand how I would apply this advice.\r\n\r\nBinding this tuple into the key derivation process is a neat idea.  If both sides have a clear prior notion of the peer identity that they expect to be talking to, or they can learn that identity from the ClientHello (the PSK ID probably), then this sort of approach is good.  In the latter case, inclusion in the transcript could replace use of the context, though there is no harm in having this information included in both place.  Note that any explicit identifier the client provides wouldn't be confidentiality protected from passive observers.\r\n\r\nHowever, the recommendation here is for the creation of a special fingerprint that might be used to correlate activity from a client (or server) in different contexts.  That's not advice I would ever want to give.  Binding activity in this way would be awesome for surveillance, but not so good for privacy.  The MAC address thing is especially problematic as it can be something that doesn't change.\r\n\r\nIf this really does depend on context, then it makes sense to have the client self-identify from within the set of nodes that share the PSK.  That identifier doesn't need to be globally unique, only unique within that smaller set.  \r\n\r\nThe server doesn't need to self-identify in signaling unless the client is connecting without a preconception of the server's identity.  If the client knows, the server could be identified in the PSK ID too.  However, if the server isn't specifically identified by the client, a pure PSK mode leaves the server no means of carrying any identification.  For that you would have to use some sort of extension, at which point the client might as well use that also.\r\n\r\nPart of what we'll end up having to deal with is whether the PSK ID identifies the key or it identifies the group key AND the identity/role of the entity that is using that key.  As this text says - and I agree - we'd previously assumed that it was the key+identity tuple.  We're learning that some applications have stretched that definition; maybe it's time to build a second, explicit field to carry the identity/role.\r\n\r\nThat all seems like a lot of new *stuff*.  It's almost like you need to think about creating a new \"PSK participant\" extension rather than try to fix all the woes of PSK use in this draft.",
              "createdAt": "2019-11-11T02:58:50Z",
              "updatedAt": "2019-11-11T03:51:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODU3MzU2",
      "title": "Clarify wire protocol changes. Apply other editorial changes.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #23.\r\n\r\ncc @martinthomson",
      "createdAt": "2019-11-21T05:56:27Z",
      "updatedAt": "2019-11-26T19:10:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "215ea8f38492e8f5e104ee9bf5fc1d555479a56e",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/clarifications",
      "headRefOid": "ef44944a851ff6b4cdc7dc7b9381580e34ccd551",
      "closedAt": "2019-11-26T19:07:27Z",
      "mergedAt": "2019-11-26T19:07:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3f96adb60e9ff801a19eec5a9375ce0de0128aee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxMjg0NjE5",
          "commit": {
            "abbreviatedOid": "885ba7e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-22T01:06:08Z",
          "updatedAt": "2019-11-22T01:06:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNjY2MDkz",
          "commit": {
            "abbreviatedOid": "885ba7e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-26T00:35:37Z",
          "updatedAt": "2019-11-26T00:39:37Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nidentities if not imported correctly. Endpoints MAY incrementally deploy PSK importer support\r\n```",
              "createdAt": "2019-11-26T00:35:38Z",
              "updatedAt": "2019-11-26T19:07:12Z"
            },
            {
              "originalPosition": 28,
              "body": "I don't think that there is anything forcing identities to be distinct, other than perhaps the normative force of a statement in this document.  A non-imported PSK could use an identity that collides with an imported one.",
              "createdAt": "2019-11-26T00:36:38Z",
              "updatedAt": "2019-11-26T19:07:12Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nof ImportedIdentity is used as the content of PskIdentity.identity in the PSK extension.\r\n```",
              "createdAt": "2019-11-26T00:38:15Z",
              "updatedAt": "2019-11-26T19:07:12Z"
            },
            {
              "originalPosition": 149,
              "body": "Not that it matters, but numbers are right-aligned.\r\n\r\n```suggestion\r\n|:-------------------|-------:|\r\n```",
              "createdAt": "2019-11-26T00:39:09Z",
              "updatedAt": "2019-11-26T19:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMjE5MTcw",
          "commit": {
            "abbreviatedOid": "ef44944"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T19:08:46Z",
          "updatedAt": "2019-11-26T19:08:47Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "True, though this sentence is primarily about collisions across identities given the same input PSK.",
              "createdAt": "2019-11-26T19:08:46Z",
              "updatedAt": "2019-11-26T19:08:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMjIwMTE0",
          "commit": {
            "abbreviatedOid": "ef44944"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T19:10:23Z",
          "updatedAt": "2019-11-26T19:10:24Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I didn't apply this suggestion since this is not about the import behavior per-se, so I didn't want to apply any type of normative hint. ",
              "createdAt": "2019-11-26T19:10:24Z",
              "updatedAt": "2019-11-26T19:10:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc5NzI0MzE1",
      "title": "Less circular definitions for identity",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/25",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This isn't perfect either, but it concentrates on the functional side,\r\nnamely that we use a sequence of bytes to identify PSKs.",
      "createdAt": "2020-02-25T18:10:02Z",
      "updatedAt": "2020-02-25T19:36:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "eb6dea20ca7ec44209c79945806719077bb59d81",
      "headRepository": "martinthomson/draft-ietf-tls-external-psk-importer",
      "headRefName": "identity-isnt-right",
      "headRefOid": "d11e3cd0f2be905ff5068b67406b24c0d5b7ac74",
      "closedAt": "2020-02-25T19:36:18Z",
      "mergedAt": "2020-02-25T19:36:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0af7361e5a24bd9d7ce473c3edc0c36db6eeec21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzkyNzA3",
          "commit": {
            "abbreviatedOid": "d11e3cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-25T19:36:12Z",
          "updatedAt": "2020-02-25T19:36:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTM5NDU1",
      "title": "Clarify single hash function requirements.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #26.\r\n\r\ncc @sayrer",
      "createdAt": "2020-03-28T19:03:24Z",
      "updatedAt": "2020-03-28T21:17:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "0af7361e5a24bd9d7ce473c3edc0c36db6eeec21",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/clarify-requirements",
      "headRefOid": "bb5dcbeecc0de22d7c0f2590c5405704a4357e32",
      "closedAt": "2020-03-28T21:16:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a clarifying change on #28 -- closing in favor of that PR!",
          "createdAt": "2020-03-28T21:16:59Z",
          "updatedAt": "2020-03-28T21:16:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzQ2NDEy",
          "commit": {
            "abbreviatedOid": "bb5dcbe"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-28T20:22:05Z",
          "updatedAt": "2020-03-28T20:22:06Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Does this mean you must not use the key you are feeding into the importer or the key you derive from the importer?",
              "createdAt": "2020-03-28T20:22:05Z",
              "updatedAt": "2020-03-28T20:22:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzQ2NTkz",
          "commit": {
            "abbreviatedOid": "bb5dcbe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-28T20:24:37Z",
          "updatedAt": "2020-03-28T20:24:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "The former, though that may be a bit too strong of a requirement. ",
              "createdAt": "2020-03-28T20:24:38Z",
              "updatedAt": "2020-03-28T20:24:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzQ5NDcw",
          "commit": {
            "abbreviatedOid": "bb5dcbe"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-28T21:03:45Z",
          "updatedAt": "2020-03-28T21:03:46Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "As I understand the technical requirement it's that you must only use it with HKDF with that hash and a unique label. So if, for instance, you were to HKDF with a label that guaranteed non-collision with importers, that would be OK, right",
              "createdAt": "2020-03-28T21:03:46Z",
              "updatedAt": "2020-03-28T21:03:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzQ5NjIw",
          "commit": {
            "abbreviatedOid": "bb5dcbe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-28T21:05:35Z",
          "updatedAt": "2020-03-28T21:05:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "That's right, and that's what the security considerations discuss. (Are you looking for a change in text here?)",
              "createdAt": "2020-03-28T21:05:36Z",
              "updatedAt": "2020-03-28T21:05:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTQ5NDA0",
      "title": "Editorial pass to simplify text and unify terminology.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/28",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mainly editorial, so there should be nothing surprising here. Please let me if that's not the case!\r\n\r\nIt also includes clarifying text per @sayrer's recommendation raised during WGLC.\r\n\r\ncc @jhoyla @martinthomson ",
      "createdAt": "2020-03-28T20:21:04Z",
      "updatedAt": "2020-04-08T01:09:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "0af7361e5a24bd9d7ce473c3edc0c36db6eeec21",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/edits",
      "headRefOid": "6f55693dbbf1a218525d00cc31a00fbfcdd76904",
      "closedAt": "2020-04-08T01:09:58Z",
      "mergedAt": "2020-04-08T01:09:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2c81561cb7bc0b921926aeff17fdcd0d057173a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzUwNDU1",
          "commit": {
            "abbreviatedOid": "27ae00c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-28T21:18:32Z",
          "updatedAt": "2020-03-28T21:18:32Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "@sayrer this should address your comment. Please let me know if not!",
              "createdAt": "2020-03-28T21:18:32Z",
              "updatedAt": "2020-04-08T01:09:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTUzMzQy",
          "commit": {
            "abbreviatedOid": "27ae00c"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-01T21:13:21Z",
          "updatedAt": "2020-04-01T21:13:22Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "WFM",
              "createdAt": "2020-04-01T21:13:22Z",
              "updatedAt": "2020-04-08T01:09:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTQzMjc0",
          "commit": {
            "abbreviatedOid": "27ae00c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-07T22:49:08Z",
          "updatedAt": "2020-04-07T22:54:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "s/diversify/diversifies/",
              "createdAt": "2020-04-07T22:49:08Z",
              "updatedAt": "2020-04-08T01:09:24Z"
            },
            {
              "originalPosition": 183,
              "body": "This is an existing sentence, but the word \"minimally\" here is interesting given PSKs meant for use with non-QUIC connections don't need QUIC transport settings (nitpick: I think QUIC calls them \"transport parameters\").",
              "createdAt": "2020-04-07T22:53:40Z",
              "updatedAt": "2020-04-08T01:09:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTkwNDMz",
          "commit": {
            "abbreviatedOid": "6f55693"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T01:09:39Z",
          "updatedAt": "2020-04-08T01:09:39Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Good catch -- fixed!",
              "createdAt": "2020-04-08T01:09:39Z",
              "updatedAt": "2020-04-08T01:09:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAxNzUxMDI0",
      "title": "Tighten up IANA considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/29",
      "state": "MERGED",
      "author": "jsalowey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make registry title explicit and point to request procedures 8447.",
      "createdAt": "2020-04-10T04:27:16Z",
      "updatedAt": "2020-04-22T18:29:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "4ed9a248a16161d872bbcca3578a36d9f41acf6e",
      "headRepository": "jsalowey/draft-ietf-tls-external-psk-importer",
      "headRefName": "master",
      "headRefOid": "6d83c28cc01f7aa607ccbffc7c8155f5ed9a0e39",
      "closedAt": "2020-04-22T18:29:03Z",
      "mergedAt": "2020-04-22T18:29:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c3e54b1542d272b0291e526bdf2d97f5ddf6d1c8"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Joe!",
          "createdAt": "2020-04-22T18:28:56Z",
          "updatedAt": "2020-04-22T18:28:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NDY0MTg0",
          "commit": {
            "abbreviatedOid": "da4c950"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-22T18:28:05Z",
          "updatedAt": "2020-04-22T18:28:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3MDAyMzEz",
      "title": "Apply edits from Verisign review.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/34",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #30, #31, #32, and #33.",
      "createdAt": "2020-04-22T02:18:09Z",
      "updatedAt": "2020-04-22T18:27:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "2c81561cb7bc0b921926aeff17fdcd0d057173a4",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/edits-2",
      "headRefOid": "af13f826fd492ff02ecfc56ddb8a70405ca523e1",
      "closedAt": "2020-04-22T18:27:31Z",
      "mergedAt": "2020-04-22T18:27:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ed9a248a16161d872bbcca3578a36d9f41acf6e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODE0ODY5",
          "commit": {
            "abbreviatedOid": "af13f82"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-22T03:19:20Z",
          "updatedAt": "2020-04-22T03:19:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA4ODAzMDM3",
      "title": "Couple of other notes",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-24T23:10:52Z",
      "updatedAt": "2020-05-19T02:22:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "c3e54b1542d272b0291e526bdf2d97f5ddf6d1c8",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/verisign-edits",
      "headRefOid": "2647f6222eb1fbd195298b361ee9ba6249be160a",
      "closedAt": "2020-05-19T02:22:32Z",
      "mergedAt": "2020-05-19T02:22:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "75b408ce21ff091539362f2a2dbf7c8b40acdfe6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODAxNDIy",
      "title": "Address comments raised by Verisign.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/36",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The gist of the feedback, as I understood it, was that we made claims that were quite strong. This relaxes the language a bit and draws on RFC8446 for some example text.\r\n\r\ncc @davidben @ekr @martinthomson ",
      "createdAt": "2020-05-19T00:01:20Z",
      "updatedAt": "2020-05-19T16:22:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "c3e54b1542d272b0291e526bdf2d97f5ddf6d1c8",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/verisign-review",
      "headRefOid": "b1324220ad502f1e3d19143ee1a894641229ec92",
      "closedAt": "2020-05-19T16:22:14Z",
      "mergedAt": "2020-05-19T16:22:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6a9741a3d9483ff3b8707f15bc245a1288125546"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDQzOTQz",
          "commit": {
            "abbreviatedOid": "18e173e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Hard to pick up the differences here, but I think that I got them.",
          "createdAt": "2020-05-19T01:40:13Z",
          "updatedAt": "2020-05-19T01:40:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxODczNTc3",
      "title": "Address OPS, GENART, and Roman reviews.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/40",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #37, #38, and #39.\r\n\r\ncc @davidben ",
      "createdAt": "2020-12-03T15:35:37Z",
      "updatedAt": "2020-12-03T16:00:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "8cbb475bf6eb30573f049e88a9f0a0a22c7ebd93",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/address-ops-and-gen",
      "headRefOid": "8fd5666793fd8cc26943898b91527ba5eea18748",
      "closedAt": "2020-12-03T16:00:56Z",
      "mergedAt": "2020-12-03T16:00:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2b55050e1a4b9bb0dbac998be1d4dd848729513d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTA2NzYy",
          "commit": {
            "abbreviatedOid": "a64de43"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-03T15:52:57Z",
          "updatedAt": "2020-12-03T15:55:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Incredibly nitpicky nitpick: it seems RFC 5246 just writes \"pseudorandom function\" (all lowercase).\r\n\r\nRFC 5869 likewise doesn't capitalize \"key derivation function\" when defining KDF. (RFC 8446 doesn't seem to ever expand it.)",
              "createdAt": "2020-12-03T15:52:58Z",
              "updatedAt": "2020-12-03T15:59:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTEyNzE4",
          "commit": {
            "abbreviatedOid": "93107d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T15:58:27Z",
          "updatedAt": "2020-12-03T15:58:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Thanks, stand by!",
              "createdAt": "2020-12-03T15:58:27Z",
              "updatedAt": "2020-12-03T15:59:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc4ODUwNDM2",
      "title": "Proposed text to address Martin Duke's DISCUSS",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/41",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-24T00:10:21Z",
      "updatedAt": "2021-05-24T22:38:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "2b55050e1a4b9bb0dbac998be1d4dd848729513d",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "f9de73697193033b3f76faec24339ab3a0e937e1",
      "closedAt": "2021-05-24T22:38:57Z",
      "mergedAt": "2021-05-24T22:38:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dc360a4355e68aaf34796d53f0adcb3429c7ea17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2OTI5OTgz",
          "commit": {
            "abbreviatedOid": "959ea78"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-24T00:30:52Z",
          "updatedAt": "2021-02-24T00:30:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nAs the maximum size of the PSK extension is 2^16 - 1 octets, an Imported Identity that exceeds this size is likely to cause a decoding error. Therefore, the PSK Importer interface SHOULD reject any ImportedIdentity that exceeds this size.\r\n```",
              "createdAt": "2021-02-24T00:30:52Z",
              "updatedAt": "2021-02-24T00:30:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ3MTMw",
          "commit": {
            "abbreviatedOid": "ba9deee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:38:41Z",
          "updatedAt": "2021-05-24T22:38:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nAs the maximum size of the PSK extension is 2^16 - 1 octets, an Imported Identity that exceeds \r\nthis size is likely to cause a decoding error. Therefore, the PSK Importer interface SHOULD reject \r\nany ImportedIdentity that exceeds this size.\r\n\r\n```",
              "createdAt": "2021-05-24T22:38:41Z",
              "updatedAt": "2021-05-24T22:38:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ3MTk0",
          "commit": {
            "abbreviatedOid": "ba9deee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-24T22:38:50Z",
          "updatedAt": "2021-05-24T22:38:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNjY2ODc4",
      "title": "Address Ben's IESG feedback.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/43",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I don't love a couple of the ways I phrased things here, so feel free to offer suggestions to improve it! \r\n\r\nCloses #42, modulo test vectors. (@kaduk, it'll likely take some time to get those vectors. Do you think we should hold this document until that's done?)",
      "createdAt": "2021-05-24T22:06:43Z",
      "updatedAt": "2022-03-07T14:17:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "2b55050e1a4b9bb0dbac998be1d4dd848729513d",
      "headRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "headRefName": "caw/ben-edits",
      "headRefOid": "d9b2d319d2f7ba53459a4b90efc3d337b8911733",
      "closedAt": "2022-03-07T14:17:58Z",
      "mergedAt": "2022-03-07T14:17:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7977a4e59bb8bd4aa6742e135828e9fa8b8967a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjM1NzE4",
          "commit": {
            "abbreviatedOid": "8629d37"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:12:30Z",
          "updatedAt": "2021-05-24T22:23:46Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I guess this is existing text, but I'm not sure RFC8446 actually covers. RFC8446 applies to what TLS 1.3 calls an external PSK. But we've got our own root secret and uses of KDFs. So I think we have to state that rule anew.\r\n\r\n(RFC8446 would apply to our derived PSKs, but those satisfy the rules by construction.)",
              "createdAt": "2021-05-24T22:12:30Z",
              "updatedAt": "2021-05-24T22:23:46Z"
            },
            {
              "originalPosition": 80,
              "body": "Super nitpicky nitpick: should we s/i.e./e.g./? SHA-256 is still just an example.",
              "createdAt": "2021-05-24T22:13:49Z",
              "updatedAt": "2021-05-24T22:23:46Z"
            },
            {
              "originalPosition": 125,
              "body": "Hrm. I'm very confused what this section is saying, with both new and old text. :-) Are we saying that you take the EPSK and plug it directly into your TLS 1.2 API, without any derivation step at all? I guess that's the only way existing applications can avoid rekeying... but I'm not sure the safety claims hold, at least not obviously.\r\n\r\nWe'd need to confirm that the TLS 1.2 PRF is separated from our derivation construction. Also TLS 1.2 doesn't not lock things to algorithms, so we'd also have to believe that SHA-256, SHA-384, and MD5/SHA-1 are sufficiently unrelated to the EPSK KDF hash. (Which, let's be honest, is probably true. But if we were okay with that, we wouldn't have gotten ourselves into this mess. :-) )\r\n\r\nOr am I completely misunderstanding what this is saying?\r\n\r\nEdit: Oh, I guess we have some text on this in security considerations. Though this section reads much more certain than security considerations does.",
              "createdAt": "2021-05-24T22:21:18Z",
              "updatedAt": "2021-05-24T22:23:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ3NDc4",
          "commit": {
            "abbreviatedOid": "8629d37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:39:27Z",
          "updatedAt": "2021-05-24T22:39:27Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\noutput, e.g., 32 octets for SHA256. This is required for the IPSK to be of length suitable\r\n```",
              "createdAt": "2021-05-24T22:39:27Z",
              "updatedAt": "2021-05-24T22:39:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ3NDk2",
          "commit": {
            "abbreviatedOid": "8629d37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:39:30Z",
          "updatedAt": "2021-05-24T22:39:31Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Yep!",
              "createdAt": "2021-05-24T22:39:30Z",
              "updatedAt": "2021-05-24T22:39:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ4MTYy",
          "commit": {
            "abbreviatedOid": "8629d37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:40:29Z",
          "updatedAt": "2021-05-24T22:40:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Hmm, can you propose text? I'm not sure what specifically which rule you're referring to. (Maybe that each PSK has an associated hash function?) ",
              "createdAt": "2021-05-24T22:40:29Z",
              "updatedAt": "2021-05-24T22:40:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ5MDAy",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:42:07Z",
          "updatedAt": "2021-05-24T22:42:07Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yeah, you basically have it right. (Matches my mental model.) Feel free to suggest alternative phrasings if you have them, or maybe we just drop a pointer to the security considerations? I don't feel strongly either way.",
              "createdAt": "2021-05-24T22:42:07Z",
              "updatedAt": "2021-05-24T22:42:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTQwMzA4",
          "commit": {
            "abbreviatedOid": "8629d37"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T21:08:33Z",
          "updatedAt": "2021-05-26T21:19:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yeah, that each PSK has an associated hash function applies to IPSKs, not EPSKs. Perhaps we can just replace:\r\n\r\n> , as per the rules in Section 4.2.11 from {{!RFC8446}}.\r\n\r\nwith:\r\n\r\n> . This is analogous to the rules in Section 4.2.11 of {{!RFC8446}}.",
              "createdAt": "2021-05-26T21:08:33Z",
              "updatedAt": "2021-05-26T21:19:30Z"
            },
            {
              "originalPosition": 125,
              "body": "I guess I would have just dropped this, though I also don't care very much about existing TLS 1.2 uses and others probably do.\r\n\r\nBTW, this section also contradicts this text:\r\n>    Endpoints which import external keys MUST NOT use either the external\r\n>    keys or the derived keys for any other purpose\r\n\r\nOn alternate phrasings, I guess the question is what we want to say. We could say any of:\r\n\r\n1. You're not allowed to use EPSKs directly in TLS 1.2. It's not safe. If you have an existing TLS 1.2 PSKs, you've got to provision parallel 1.2 PSKs and EPSKs until you've migrated off TLS 1.2.\r\n2. You're allowed to derive IPSKs from EPSKs for use with TLS 1.2. This doesn't help existing TLS 1.2 PSKs, and new things should use TLS 1.3, so this seems not useful.\r\n3. You're allowed to take a TLS 1.2 PSK and use it as an EPSK directly. This contradicts the MUST NOT above and is not obviously safe. So maybe we say it's NOT RECOMMENDED and tell people to quickly migrate TLS 1.2 off? Though that's kinda RFC6919-y.\r\n4. Same as above but we claim it's safe. We'd probably need someone to do some analysis here.\r\n5. Define a way to derive an EPSK from a TLS 1.2 PSK using the TLS 1.2 PRF, in hopes that it is more clearly separated. Though even that is slightly a lost cause because TLS 1.2 PSKs were themselves not clearly separated. This gives a transition path, but it means that, even when your system removes TLS 1.3, you've still got that extra derivation step in there.\r\n\r\nIncidentally, my [old draft](https://datatracker.ietf.org/doc/html/draft-davidben-tls-universal-psk-00#section-3) did (5).\r\n\r\nWhich do you think we should do?",
              "createdAt": "2021-05-26T21:19:27Z",
              "updatedAt": "2021-05-26T21:20:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTUzNDc0",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T21:23:09Z",
          "updatedAt": "2021-05-26T21:23:09Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I think we should aim for minimal changes to TLS 1.2 at this point, so I'd be inclined to go with (3) or (4). ",
              "createdAt": "2021-05-26T21:23:09Z",
              "updatedAt": "2021-05-26T21:23:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTUzNTU4",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T21:23:16Z",
          "updatedAt": "2021-05-26T21:23:16Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yeah, that works!",
              "createdAt": "2021-05-26T21:23:16Z",
              "updatedAt": "2021-05-26T21:23:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTU5MTAw",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T21:31:25Z",
          "updatedAt": "2021-05-26T21:31:26Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Well I think only (2) involves changes to TLS 1.2. It's also not really useful, so we can discard it.\r\n\r\n(1) simply says that your `ConfigureTLS12PSK` API doesn't do anything useful with PSK importers, and that you MUST (BUT WE KNOW YOU WON'T) use separate PSKs with TLS 1.3. For instance, your PSK issuance logic could issue parallel keys for TLS 1.2 and EPSKs. But this means you cannot enable TLS 1.3 transparently on clients that haven't gotten parallel PSKs issued. Depending on your application, this may be easy or very inconvenient. But it's sound on the TLS 1.3 path and TLS 1.2 is no more or less sound than before.\r\n\r\n(3) and (4) say that your `ConfigureTLS12PSK` API (optionally? by default?) also is a `ConfigureEPSK` API and we'll reuse the keys. This means you can enable TLS 1.3 transparently, but it's not really sound and you OUGHT TO get rid of TLS 1.2 in your application.\r\n\r\n(5) says that, if you call `ConfigureEPSK`, you get the EPSK thing in this draft. If you call `ConfigureTLS12PSK(psk)`, as a compatibility scheme, the library will internally also call `ConfigureEPSK(DeriveEPSKFromTLS12PSK(psk))`. This means you can enable TLS 1.3 transparently, but when you drop TLS 1.2 support, you'll still need to go through the `DeriveEPSKFromTLS12PSK` codepath until you, like (1), drive fresh keys. But it's sound on the TLS 1.3 path, TLS 1.2 is no more or less sound than before, though TLS 1.2's unsoundness might bleed a little into TLS 1.3 with the `DeriveEPSKFromTLS12PSK` call.",
              "createdAt": "2021-05-26T21:31:25Z",
              "updatedAt": "2021-05-26T21:32:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTczNzMw",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T21:54:33Z",
          "updatedAt": "2021-05-26T21:54:33Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Oh, I guess I misunderstood you. If (5) is just _using_ the TLS 1.2 PRF, that would be fine, I guess. This will require more invasive changes to the draft for 1.2, though, which is... a bummer. Do you think you'd have cycles to do that? (I'm not sure when I'd be able to get to it, but I can try to prioritize if you're also swamped.)",
              "createdAt": "2021-05-26T21:54:33Z",
              "updatedAt": "2021-05-26T21:54:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwMzIyMTEw",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-27T15:19:26Z",
          "updatedAt": "2021-05-27T15:19:27Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yeah, I'm not sure whether (5) is worth it. I guess it's also a pretty big change to be doing this late. I don't feel super strongly about what to do here... my immediate comment is just that the current text can't seem to decide between (3) and (4). And that, if we assert it's safe, it should actually be safe. :-)\r\n\r\nCycles-wise, not sure when I'd be able to get to it either. (Right now I really want to finish that ECH implementation.)",
              "createdAt": "2021-05-27T15:19:26Z",
              "updatedAt": "2021-05-27T15:19:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCH3yJc4vPVQr",
          "commit": {
            "abbreviatedOid": "23765d2"
          },
          "author": "kaduk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This looks good modulo the open issue about incremental deployment.\r\n\r\nI don't think we need to hold the document up in order to get test vectors.",
          "createdAt": "2021-10-29T01:19:24Z",
          "updatedAt": "2021-10-29T02:16:26Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nimporter process MUST be associated with at most one hash function.  This\r\nis analogous to the rules in Section 4.2.11 of {{!RFC8446}}. See {{security-considerations}} for\r\n```",
              "createdAt": "2021-10-29T01:19:24Z",
              "updatedAt": "2021-10-29T02:16:26Z"
            },
            {
              "originalPosition": 125,
              "body": "In an effort to avoid RFC 6919 language, I have an alternate approach to propose.  (I agree that the current text is trying to decide between (3) and (4).):\r\n\r\nThe mechanism defined in this document requires that an EPSK is only ever used as an EPSK; in particular, this requirement disallows direct use of the EPSK as a PSK in TLS 1.2.  Instead, distinct IPSKs are derived based on the target protocol and KDF; this protects against cross-protocol collisions for protocol versions using importers by ensuring that each IPSK can only be used with one protocol and KDF.  This is a distinct contrast to TLS 1.2, where a given PSK might be used with multiple KDFs in different handshakes, and importers are not available.  Furthermore, the KDF used in TLS 1.2 might be the same KDF used by the importer mechanism itself.  In deployments that already have PSKs provisioned and in use with TLS 1.2, attempting to incrementally deploy the importer mechanism would then result in concurrent use of the already provisioned PSK both directly as a TLS 1.2 PSK and as an EPSK, which in turn could mean that the same KDF and key would be used in two different protocol contexts.  This scenario does not have a cryptographic analysis of soundness and is not a recommended configuration.  However, the benefits of using TLS 1.3 and of using PSK importers may prove sufficiently compelling that existing deployments choose to enable this noncompliant configuration for a brief transition period while new software (using TLS 1.3 and importers) is deployed.  Since the transition configuration involving concurrent use of a PSK as both a TLS 1.2 PSK and an EPSK does not have a proof of cryptographic soundness, operators are advised to make any such transition period as short as possible.\r\n",
              "createdAt": "2021-10-29T01:50:59Z",
              "updatedAt": "2021-10-29T02:16:26Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nsending early data. Minimally, that means Application-Layer Protocol Negotiation value\r\n```",
              "createdAt": "2021-10-29T02:13:31Z",
              "updatedAt": "2021-10-29T02:16:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCH3yJc41taf1",
          "commit": {
            "abbreviatedOid": "ab56a36"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-06T16:48:14Z",
          "updatedAt": "2022-03-06T16:48:14Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Thanks @kaduk! I refactored this suggestion and applied it. I'll aim to submit tomorrow before the deadline. Note that we may want to pause this document to collect implementation experience and additional analysis.",
              "createdAt": "2022-03-06T16:48:14Z",
              "updatedAt": "2022-03-06T16:48:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOCH3yJc4tpcj8",
      "title": "Don't use \"replace\" when describing the binder_key derivation string.",
      "url": "https://github.com/tlswg/draft-ietf-tls-external-psk-importer/pull/44",
      "state": "MERGED",
      "author": "tmshort",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It's a bit confusing to use the term \"replace\" when discussing the string\r\nused for derivation. The text only references one of the strings used for\r\nderivation where the diagram references two.",
      "createdAt": "2021-10-25T21:00:11Z",
      "updatedAt": "2021-10-25T21:48:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-external-psk-importer",
      "baseRefName": "master",
      "baseRefOid": "dc360a4355e68aaf34796d53f0adcb3429c7ea17",
      "headRepository": "tmshort/draft-ietf-tls-external-psk-importer",
      "headRefName": "binder_key",
      "headRefOid": "fbdbb421c0328cd46ac958ad45c58bc849ece913",
      "closedAt": "2021-10-25T21:48:52Z",
      "mergedAt": "2021-10-25T21:48:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "64f9b4fc90f72983994ce34c9b76c62515d6fa66"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCH3yJc4vAd9B",
          "commit": {
            "abbreviatedOid": "fbdbb42"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T21:48:47Z",
          "updatedAt": "2021-10-25T21:48:47Z",
          "comments": []
        }
      ]
    }
  ]
}